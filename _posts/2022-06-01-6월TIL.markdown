---
layout: post
title: "2022년 6월 TIL"
date: 2022-06-01 22:00:00 +0900
categories: 202206 TIL
---

### 6/1(수)

코딩으로 학습하는 GoF의 디자인 패턴 - 옵저버 패턴 5부<br/>
스프링에서 찾아보는 패턴

-   스프링
    -   ApplicationContext와 ApplicationEvent

---

### 6/2(목)

코딩으로 학습하는 GoF의 디자인 패턴 - 상태 패턴 1부<br/>
패턴 소개

**상태(State) 패턴: 객체 내부 상태 변경에 따라 객체의 행동이 달라지는 패턴<br/>
상태에 특화된 행동들을 분리해 낼 수 있으며, 새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.**

---

### 6/3(금)

코딩으로 학습하는 GoF의 디자인 패턴 - 상태 패턴 2부<br/>
패턴 적용하기

```java
//Student
public class Student {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    private Set<OnlineCourse> onlineCourses = new HashSet<>();

    public boolean isAvailable(OnlineCourse onlineCourse) {
        return onlineCourses.contains(onlineCourse);
    }

    public void addPrivate(OnlineCourse onlineCourse) {
        this.onlineCourses.add(onlineCourse);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
//OnlineCourse
public class OnlineCourse {
    private State state = new Draft(this);

    private List<Student> students = new ArrayList<>();

    private List<String> reviews = new ArrayList<>();

    public void addStudent(Student student) {
        this.state.addStudent(student);
    }

    public void addReview(String review, Student student) {
        this.state.addReview(review, student);
    }

    public State getState() {
        return state;
    }

    public List<Student> getStudents() {
        return students;
    }

    public List<String> getReviews() {
        return reviews;
    }

    public void changeState(State state) {
        this.state = state;
    }
}
```

```java
//State
public interface State {
    void addReview(String review, Student student);

    void addStudent(Student student);
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        OnlineCourse onlineCourse = new OnlineCourse();
        Student student = new Student("whiteship");
        Student keesun = new Student("keesun");
        keesun.addPrivate(onlineCourse);

        onlineCourse.addStudent(student);

        onlineCourse.changeState(new Private(onlineCourse));

        onlineCourse.addReview("hello", student);

        onlineCourse.addStudent(keesun);

        System.out.println(onlineCourse.getState());
        System.out.println(onlineCourse.getReviews());
        System.out.println(onlineCourse.getStudents());
    }
}
```

```java
//Draft
public class Draft implements State {
    private OnlineCourse onlineCourse;

    public Draft(OnlineCourse onlineCourse) {
        this.onlineCourse = onlineCourse;
    }

    @Override
    public void addReview(String review, Student student) {
        throw new UnsupportedOperationException("드래프트 상태에서는 리뷰를 남길 수 없습니다.");
    }

    @Override
    public void addStudent(Student student) {
        this.onlineCourse.getStudents().add(student);
        if (this.onlineCourse.getStudents().size() > 1) {
            this.onlineCourse.changeState(new Private(this.onlineCourse));
        }
    }
}
```

```java
//Private
public class Private implements State {
    private OnlineCourse onlineCourse;

    public Private(OnlineCourse onlineCourse) {
        this.onlineCourse = onlineCourse;
    }

    @Override
    public void addReview(String review, Student student) {
        if (this.onlineCourse.getStudents().contains(student)) {
            this.onlineCourse.getReviews().add(review);
        } else {
            throw new UnsupportedOperationException("프라이빗 코스를 수강하는 학생만 리뷰를 남길 수 있습니다.");
        }
    }

    @Override
    public void addStudent(Student student) {
        if (student.isAvailable(this.onlineCourse)) {
            this.onlineCourse.getStudents().add(student);
        } else {
            throw new UnsupportedOperationException("프라이빗 코스를 수강할 수 없습니다.");
        }
    }
}
```

```java
//Published
public class Published implements State {
    private OnlineCourse onlineCourse;

    public Published(OnlineCourse onlineCourse) {
        this.onlineCourse = onlineCourse;
    }

    @Override
    public void addReview(String review, Student student) {
        this.onlineCourse.getReviews().add(review);
    }

    @Override
    public void addStudent(Student student) {
        this.onlineCourse.getStudents().add(student);
    }
}
```

---

### 6/4(토)

코딩으로 학습하는 GoF의 디자인 패턴 - 상태 패턴 3부<br/>
장점과 단점

-   장점
    -   상태에 따른 동작을 개별 클래스로 옮겨서 관리할 수 있다.
    -   기존의 특정 상태에 따른 동작을 변경하지 않고 새로운 상태에 다른 동작을 추가할 수 있다.
    -   코드 복잡도를 줄일 수 있다.
-   단점
    -   복잡도가 증가한다.

---

### 6/5(일)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 1부<br/>
패턴 소개

**전략(Strategy) 패턴: 여러 알고리즘을 캡슐화하고 상호 교환 가능하게 만드는 패턴<br/>
컨텍스트에서 사용할 알고리즘을 클라이언트가 선택한다.**

---

### 6/6(월)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 2부<br/>
패턴 적용하기

```java
//BlueLightRedLight
public class BlueLightRedLight {
    public void blueLight(Speed speed) {
        speed.blueLight();
    }

    public void redLight(Speed speed) {
        speed.redLight();
    }
}
```

```java
//Speed
public interface Speed {
    void blueLight();
    void redLight();
}
```

```java
//Normal
public class Normal implements Speed {
    @Override
    public void blueLight() {
        System.out.println("무 궁 화    꽃   이");
    }

    @Override
    public void redLight() {
        System.out.println("피 었 습 니  다.");
    }
}
```

```java
//Faster
public class Faster implements Speed {
    @Override
    public void blueLight() {
        System.out.println("무궁화꽃이");
    }

    @Override
    public void redLight() {
        System.out.println("피었습니다.");
    }
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        BlueLightRedLight game = new BlueLightRedLight();
        game.blueLight(new Normal());
        game.redLight(new Faster());
        game.blueLight(new Speed() {
            @Override
            public void blueLight() {
                System.out.println("blue light");
            }

            @Override
            public void redLight() {
                System.out.println("red light");
            }
        });
    }
}
```

---

### 6/7(화)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 3부<br/>
장점과 단점

-   장점
    -   새로운 전략을 추가하더라도 기존 코드를 변경하지 않는다.
    -   상속 대신 위임을 사용할 수 있다.
    -   런타임에 전략을 변경할 수 있다.
-   단점
    -   복잡도가 증가한다.
    -   클라이언트 코드가 구체적인 전략을 알아야 한다.

---

### 6/8(수)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 4부<br/>
자바와 스프링에서 찾아보는 패턴

-   자바
    -   Comparator
-   스프링
    -   ApplicationContext
    -   PlatformTransactionManager

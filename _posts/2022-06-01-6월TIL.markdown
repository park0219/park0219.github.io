---
layout: post
title: "2022년 6월 TIL"
date: 2022-06-01 22:00:00 +0900
categories: 202206 TIL
---

### 6/1(수)

코딩으로 학습하는 GoF의 디자인 패턴 - 옵저버 패턴 5부<br/>
스프링에서 찾아보는 패턴

-   스프링
    -   ApplicationContext와 ApplicationEvent

---

### 6/2(목)

코딩으로 학습하는 GoF의 디자인 패턴 - 상태 패턴 1부<br/>
패턴 소개

**상태(State) 패턴: 객체 내부 상태 변경에 따라 객체의 행동이 달라지는 패턴<br/>
상태에 특화된 행동들을 분리해 낼 수 있으며, 새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.**

---

### 6/3(금)

코딩으로 학습하는 GoF의 디자인 패턴 - 상태 패턴 2부<br/>
패턴 적용하기

```java
//Student
public class Student {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    private Set<OnlineCourse> onlineCourses = new HashSet<>();

    public boolean isAvailable(OnlineCourse onlineCourse) {
        return onlineCourses.contains(onlineCourse);
    }

    public void addPrivate(OnlineCourse onlineCourse) {
        this.onlineCourses.add(onlineCourse);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
//OnlineCourse
public class OnlineCourse {
    private State state = new Draft(this);

    private List<Student> students = new ArrayList<>();

    private List<String> reviews = new ArrayList<>();

    public void addStudent(Student student) {
        this.state.addStudent(student);
    }

    public void addReview(String review, Student student) {
        this.state.addReview(review, student);
    }

    public State getState() {
        return state;
    }

    public List<Student> getStudents() {
        return students;
    }

    public List<String> getReviews() {
        return reviews;
    }

    public void changeState(State state) {
        this.state = state;
    }
}
```

```java
//State
public interface State {
    void addReview(String review, Student student);

    void addStudent(Student student);
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        OnlineCourse onlineCourse = new OnlineCourse();
        Student student = new Student("whiteship");
        Student keesun = new Student("keesun");
        keesun.addPrivate(onlineCourse);

        onlineCourse.addStudent(student);

        onlineCourse.changeState(new Private(onlineCourse));

        onlineCourse.addReview("hello", student);

        onlineCourse.addStudent(keesun);

        System.out.println(onlineCourse.getState());
        System.out.println(onlineCourse.getReviews());
        System.out.println(onlineCourse.getStudents());
    }
}
```

```java
//Draft
public class Draft implements State {
    private OnlineCourse onlineCourse;

    public Draft(OnlineCourse onlineCourse) {
        this.onlineCourse = onlineCourse;
    }

    @Override
    public void addReview(String review, Student student) {
        throw new UnsupportedOperationException("드래프트 상태에서는 리뷰를 남길 수 없습니다.");
    }

    @Override
    public void addStudent(Student student) {
        this.onlineCourse.getStudents().add(student);
        if (this.onlineCourse.getStudents().size() > 1) {
            this.onlineCourse.changeState(new Private(this.onlineCourse));
        }
    }
}
```

```java
//Private
public class Private implements State {
    private OnlineCourse onlineCourse;

    public Private(OnlineCourse onlineCourse) {
        this.onlineCourse = onlineCourse;
    }

    @Override
    public void addReview(String review, Student student) {
        if (this.onlineCourse.getStudents().contains(student)) {
            this.onlineCourse.getReviews().add(review);
        } else {
            throw new UnsupportedOperationException("프라이빗 코스를 수강하는 학생만 리뷰를 남길 수 있습니다.");
        }
    }

    @Override
    public void addStudent(Student student) {
        if (student.isAvailable(this.onlineCourse)) {
            this.onlineCourse.getStudents().add(student);
        } else {
            throw new UnsupportedOperationException("프라이빗 코스를 수강할 수 없습니다.");
        }
    }
}
```

```java
//Published
public class Published implements State {
    private OnlineCourse onlineCourse;

    public Published(OnlineCourse onlineCourse) {
        this.onlineCourse = onlineCourse;
    }

    @Override
    public void addReview(String review, Student student) {
        this.onlineCourse.getReviews().add(review);
    }

    @Override
    public void addStudent(Student student) {
        this.onlineCourse.getStudents().add(student);
    }
}
```

---

### 6/4(토)

코딩으로 학습하는 GoF의 디자인 패턴 - 상태 패턴 3부<br/>
장점과 단점

-   장점
    -   상태에 따른 동작을 개별 클래스로 옮겨서 관리할 수 있다.
    -   기존의 특정 상태에 따른 동작을 변경하지 않고 새로운 상태에 다른 동작을 추가할 수 있다.
    -   코드 복잡도를 줄일 수 있다.
-   단점
    -   복잡도가 증가한다.

---

### 6/5(일)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 1부<br/>
패턴 소개

**전략(Strategy) 패턴: 여러 알고리즘을 캡슐화하고 상호 교환 가능하게 만드는 패턴<br/>
컨텍스트에서 사용할 알고리즘을 클라이언트가 선택한다.**

---

### 6/6(월)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 2부<br/>
패턴 적용하기

```java
//BlueLightRedLight
public class BlueLightRedLight {
    public void blueLight(Speed speed) {
        speed.blueLight();
    }

    public void redLight(Speed speed) {
        speed.redLight();
    }
}
```

```java
//Speed
public interface Speed {
    void blueLight();
    void redLight();
}
```

```java
//Normal
public class Normal implements Speed {
    @Override
    public void blueLight() {
        System.out.println("무 궁 화    꽃   이");
    }

    @Override
    public void redLight() {
        System.out.println("피 었 습 니  다.");
    }
}
```

```java
//Faster
public class Faster implements Speed {
    @Override
    public void blueLight() {
        System.out.println("무궁화꽃이");
    }

    @Override
    public void redLight() {
        System.out.println("피었습니다.");
    }
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        BlueLightRedLight game = new BlueLightRedLight();
        game.blueLight(new Normal());
        game.redLight(new Faster());
        game.blueLight(new Speed() {
            @Override
            public void blueLight() {
                System.out.println("blue light");
            }

            @Override
            public void redLight() {
                System.out.println("red light");
            }
        });
    }
}
```

---

### 6/7(화)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 3부<br/>
장점과 단점

-   장점
    -   새로운 전략을 추가하더라도 기존 코드를 변경하지 않는다.
    -   상속 대신 위임을 사용할 수 있다.
    -   런타임에 전략을 변경할 수 있다.
-   단점
    -   복잡도가 증가한다.
    -   클라이언트 코드가 구체적인 전략을 알아야 한다.

---

### 6/8(수)

코딩으로 학습하는 GoF의 디자인 패턴 - 전략 패턴 4부<br/>
자바와 스프링에서 찾아보는 패턴

-   자바
    -   Comparator
-   스프링
    -   ApplicationContext
    -   PlatformTransactionManager

---

### 6/9(목)

코딩으로 학습하는 GoF의 디자인 패턴 - 템플릿 메소드 패턴 1부<br/>
패턴 소개

**템플릿 메소드(Template method) 패턴: 알고리즘 구조를 서브 클래스가 확장할 수 있도록 템플릿으로 제공하는 방법<br/>
추상 클래스는 템플릿을 제공하고 하위 클래스는 구체적인 알고리즘을 제공한다.**

---

### 6/10(금)

코딩으로 학습하는 GoF의 디자인 패턴 - 템플릿 메소드 패턴 2부<br/>
패턴 적용하기

```java
//FileProcessor
public abstract class FileProcessor {
    private String path;

    public FileProcessor(String path) {
        this.path = path;
    }

    public final int process(Operator operator) {
        try(BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;
            while((line = reader.readLine()) != null) {
                result = getResult(result, Integer.parseInt(line));
            }
            return result;
        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }

    protected abstract int getResult(int result, int number);
}
```

```java
//Plus
public class Plus extends FileProcessor {
    public Plus(String path) {
        super(path);
    }

    @Override
    protected int getResult(int result, int number) {
        return result *= number;
    }
}
```

```java
//Multiply
public class Multiply extends FileProcessor {
    public Multiply(String path) {
        super(path);
    }

    @Override
    protected int getResult(int result, int number) {
        return result *= number;
    }
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        FileProcessor fileProcessor = new Multiply("number.txt");
        int result = fileProcessor.process((sum, number) -> sum += number);
        System.out.println(result);
    }
}
```

**템플릿 콜백(Template-Callback) 패턴: 콜백으로 상속 대신 위임을 사용하는 템플릿 패턴<br/>
상속 대신 익명 내부 클래스 또는 람다 표현식을 활용할 수 있다.**

```java
//Operator
public interface Operator {
    abstract int getResult(int result, int number);
}
```

```java
//FileProcessor
public class FileProcessor {
    private String path;
    public FileProcessor(String path) {
        this.path = path;
    }

    public final int process(Operator operator) {
        try(BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;
            while((line = reader.readLine()) != null) {
                result = getResult(result, Integer.parseInt(line));
            }
            return result;
        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }
}
```

```java
//Plus
public class Plus implements Operator {
    @Override
    public int getResult(int result, int number) {
        return result += number;
    }
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        FileProcessor fileProcessor = new FileProcessor("number.txt");
        int result = fileProcessor.process((sum, number) -> sum += number);
        System.out.println(result);
    }
}
```

---

### 6/11(토)

코딩으로 학습하는 GoF의 디자인 패턴 - 템플릿 메소드 패턴 3부<br/>
장점과 단점

-   장점
    -   템플릿 코드를 재사용하고 중복 코드를 줄일 수 있다.
    -   템플릿 코드를 변경하지 않고 상속을 받아서 구체적인 알고리즘만 변경할 수 있다.
-   단점
    -   리스코프 치환 원칙을 위반할 수도 있다.
    -   알고리즘 구조가 복잡할수록 템플릿을 유지하기 어려워진다.

---

### 6/12(일)

코딩으로 학습하는 GoF의 디자인 패턴 - 템플릿 메소드 패턴 4부<br/>
자바와 스프링에서 찾아보는 패턴

-   자바
    -   HttpServlet
-   스프링
    -   템플릿 메소드 패턴
        -   Configuration
    -   템플릿 콜백 패턴
        -   JdbcTemplate
        -   RestTemplate

---

### 6/13(월)

코딩으로 학습하는 GoF의 디자인 패턴 - 방문자 패턴 1부<br/>
패턴 소개

**방문자(Visitor) 패턴: 기존 코드를 변경하지 않고 새로운 기능을 추가하는 방법<br/>
더블 디스패치(Double Dispatch)를 활용할 수 있다.**

디스패치(Dispatch): 어떤 메서드를 호출할 것인가를 결정하는 과정이다. -> 메서드의 의존성을 결정하는 과정

-   정적 디스패치: 런타임이 아닌 컴파일타임에 컴파일러, 사용자, 바이트 코드 모두 어떤 메서드가 실행될지 아는 것이다.
-   동적 디스패치: 런타임에 어떤 메서드를 실행시킬지 결정하는 것이다. 런타임에 메서드를 호출할 때 receiver parameter를 보고 어떤 객체인지 판단 후 그 클래스의 메서드를 호출한다.
-   더블 디스패치: 동적 디스패치를 두 번 하는 것이다.

---

### 6/14(화)

코딩으로 학습하는 GoF의 디자인 패턴 - 방문자 패턴 2부<br/>
패턴 적용하기

```java
//Shape
public interface Shape {
    void accept(Device device);
}
```

```java
//Circle
public class Circle implements Shape {
    @Override
    public void accept(Device device) {
        device.print(this);
    }
}
```

```java
//Rectangle
public class Rectangle implements Shape {
   @Override
    public void accept(Device device) {
        device.print(this);
    }
}
```

```java
//Triangle
public class Triangle implements Shape {
   @Override
    public void accept(Device device) {
        device.print(this);
    }
}
```

```java
//Device
public interface Device {
    void print(Circle circle);
    void print(Rectangle rectangle);
    void print(Triangle triangle);
}
```

```java
//Phone
public class Phone implements Device {
    @Override
    public void print(Circle circle) {
        System.out.println("Print Circle to Phone");
    }

    @Override
    public void print(Rectangle rectangle) {
        System.out.println("Print Rectangle to Phone");

    }

    @Override
    public void print(Triangle triangle) {
        System.out.println("Print Triangle to Phone");
    }
}
```

```java
//Watch
public class Watch implements Device {
    @Override
    public void print(Circle circle) {
        System.out.println("Print Circle to Watch");
    }

    @Override
    public void print(Rectangle rectangle) {
        System.out.println("Print Rectangle to Watch");
    }

    @Override
    public void print(Triangle triangle) {
        System.out.println("Print Triangle to Watch");
    }
}
```

```java
//Pad
public class Pad implements Device {
    @Override
    public void print(Circle circle) {
        System.out.println("Print Circle to Pad");
    }

    @Override
    public void print(Rectangle rectangle) {
        System.out.println("Print Rectangle to Pad");
    }

    @Override
    public void print(Triangle triangle) {
        System.out.println("Print Triangle to Pad");
    }
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        Shape rectangle = new Rectangle();
        Device device = new Pad();
        rectangle.accept(device);
    }
}
```

---

### 6/15(수)

코딩으로 학습하는 GoF의 디자인 패턴 - 방문자 패턴 3부<br/>
장점과 단점

-   장점
    -   기존 코드를 변경하지 않고 새로운 코드를 추가할 수 있다.
    -   추가 기능을 한 곳에 모아둘 수 있다.
-   단점
    -   복잡하다.
    -   새로운 Element를 추가하거나 제거할 때 모든 Visitor 코드를 변경해야 한다.

---

### 6/16(목)

코딩으로 학습하는 GoF의 디자인 패턴 - 방문자 패턴 4부<br/>
자바와 스프링에서 찾아보는 패턴

-   자바
    -   FileVisitor, SimpleFileVisitor
    -   AnnotationValueVisitor
    -   ElementVisitor
-   스프링
    -   BeanDefinitionVisitor

---

### 6/17(금)

객체지향의 사실과 오해 - 1. 협력하는 객체들의 공동체<br/>
협력하는 객체들의 공동체

#### 객체지향 용어 정리

-   객체지향: 실세계를 직접적이고, 직관적으로 모델링할 수 있는 패러다임이다.
-   객체지향 프로그래밍: 현실 속에 존재하는 사물을 최대한 유사하게 모방해 소프트웨어 내부로 옴겨오는 작업이다.
-   객체지향 소프트웨어: 실세계의 투영이다.
-   객체: 현실 셰게에 존재하는 사물에 대한 추상화이다.
-   객체지향의 목표: 실세계를 모방하는 것이 아니라 새로운 세계를 **창조**하는 것이다.

> 객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 캡슐화(encapsulation)하는 소프트웨어 객체의 자율성(autonomous)을 설명하는 데 효과적이다. 현실 세계의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 협력하며 목표를 달성해 나가는 과정은 메시지(message)를 주고받으며 공동의 목표를 달성하기 위해 협력(collaboration)하는 객체들의 관계를 설명하는 데 적합하다. 실세계의 사물을 기반으로 스프트웨어 객체를 식별하고 구현까지 이어간다는 개념은 객체지향 설계의 핵심 사상인 **연결완전성(seamlessness)**을 설명하는 데 적합한 틀을 제공한다.

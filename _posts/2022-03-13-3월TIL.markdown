---
layout: post
title: "2022년 3월 TIL"
date: 2022-03-15 23:00:00 +0900
categories: 202203 TIL
---

### 3/15(화)

인프런에 올라온 백기선 님의 코딩으로 학습하는 GoF의 디자인 패턴 강의를 시작했다.

코딩으로 학습하는 GoF의 디자인 패턴 - 싱글톤 패턴 1부<br/>
싱글톤 패턴을 가장 단순히 구현하는 방법

**싱글톤(Singleton) 패턴: 인스턴스를 오직 한 개만 제공하는 클래스<br/>
시스템 런타임, 환경 세팅에 대한 정보 등 인스턴스가 여러 개일 때 문제가 생길 수 있는 경우에 인스턴스를 오직 `한 개만` 만들어 제공하는 클래스가 필요하다.**

싱글톤 패턴을 구현하는 가장 단순한 방식인 private한 생성자와 static한 메소드로 객체를 생성하는 방법에 대해 학습하였다.

```java
//Settings
public class Settings {

    private static Settings instance;

    private Settings() { }

    public static Settings getInstance() {
        if (instance == null) {
            instance = new Settings();
        }
        return instance;
    }
}
```

```java
//App
public class App {
    public static void main(Strings[] args) {
        Settings settings = Settings.getInstance();
        Settings settings1 = Settings.getInstance();
        System.out.println(settings == settings1);
    }
}
```

---

### 3/16(수)

코딩으로 학습하는 GoF의 디자인 패턴 - 싱글톤 패턴 2부<br/>
멀티 쓰레드 환경에서 안전하게 싱글톤 패턴 구현하기

-   synchronized 키워드 사용하기(성능 저하 있음)

```java
//Settings
public class Settings {

    private static Settings instance;

    private Settings() { }

    public static Settings getInstance() {
        if (instance == null) {
            instance = new Settings();
        }
        return instance;
    }
}
```

-   이른 초기화(eager initialization) 사용하기(인스턴스를 미리 만들기 때문에 로딩 리소스 증가 및 미사용 가능성이 있음)

```java
//Settings
public class Settings {

    private static final Settings INSTANCE = new Settings();

    private Settings() { }

    public static Settings getInstance() {
        return INSTANCE;
    }
}
```

-   double checked locking 사용하기

```java
//Settings
public class Settings {

    //volatile 키워드 사용(자바 1.5 이상)
    private static volatile Settings instance;

    private Settings() { }

    public static Settings getInstance() {
        if (instance == null) {
            synchronized(Settings.class) {
                if(instance == null) {
                    instance = new Settings();
                }
            }
        }
        return instance;
    }
}
```

-   static inner 클래스 사용하기

```java
//Settings
public class Settings {

    private Settings() { }

    private static class SettingsHolder {
        private static final Settings INSTANCE = new Settings();
    }

    public static Settings getInstance() {
        return SettingHolder.INSTANCE;
    }
}
```

---

### 3/17(목)

코딩으로 학습하는 GoF의 디자인 패턴 - 싱글톤 패턴 3부<br/>
싱글톤 패턴 구현 방법을 깨트리는 방법

-   리플렉션 사용하기

```java
//App
public class App {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Settings settings = Settings.getInstance();

        Constructor<Settings> constructor  = Settings.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        Settings settings1 = constructor.newInstance();

        System.out.println(settings == settings1); // false
    }
}
```

-   직렬화 & 역직렬화 사용하기

```java
//Settings
public class Settings implements Serializable {

    private Settings() { }

    private static class SettingsHolder {
        private static final Settings INSTANCE = new Settings();
    }

    public static Settings getInstance() {
        return SettingHolder.INSTANCE;
    }
}
```

```java
//App
public class App {
    public static void main(String[] args) throws IOException {
        Settings settings = Settings.getInstance();
        Settings settings1 = null;

        try (ObjectOutput out = new ObjectOutputStream(new FileOutputStream("settings.obj"))) {
            out.writeObject(settings);
        }

        try (ObjectInput in = new ObjectInputStream(new FileInputStream("settings.obj"))) {
            settings1 = (Settings) in.readObject();
        }

        System.out.println(settings == settings1); // false
    }
}
```

-   역직렬화 대응 방안

```java
//Settings
public class Settings implements Serializable {

    private Settings() { }

    private static class SettingsHolder {
        private static final Settings INSTANCE = new Settings();
    }

    public static Settings getInstance() {
        return SettingHolder.INSTANCE;
    }

    protected Object readResolve() {
        return getInstance();
    }
}
```

---

### 3/18(금)

코딩으로 학습하는 GoF의 디자인 패턴 - 싱글톤 패턴 4부<br/>
안전하고 단순하게 구현하는 방법

-   enum 사용하기

    enum에서는 리플렉션을 통한 생성자 호출을 막는다.<br/>
    또한, enum은 Serializable을 구현하고 있기 때문에 직렬화, 역직렬화에서도 안전하다.<br/>
    단, 클래스를 로딩하는 시점에서 미리 만들어지고, 상속을 사용할 수 없다.(단점)

```java
//Settings
public enum Settings {
    INSTANCE;
}
```

IntelliJ에서 Bytecode 보는 법: `View` > `Show Bytecode` or `shift shift` > `Show Bytecode`

싱글톤 구현할 때 권장하는 구현 방식 2가지

-   static inner 클래스 사용하기
-   enum 사용하기

---

### 3/19(토)

코딩으로 학습하는 GoF의 디자인 패턴 - 싱글톤 패턴 5부<br/>
자바와 스프링에서 찾아보는 패턴

싱글톤 패턴이 사용되는 곳

-   스프링에서 빈의 소프트 중에 하나로 싱글톤 소코프를 사용한다.
-   자바 java.lang.Runtime
-   다른 디자인 패턴(빌더, 퍼사드, 추상 팩토리 등) 구현체의 일부로 쓰이기도 한다.

---

### 3/20(일)

코딩으로 학습하는 GoF의 디자인 패턴 - 팩토리 메소드 패턴 1부<br/>
패턴 소개

**팩토리 메소드(Factory method) 패턴: 구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.<br/>
다양한 구현체(Product)가 있고, 그중에서 특정한 구현체를 만들 수 있는 다양한 팩토리(Creator)를 제공할 수 있다.**

팩토리 메소드는 개방-폐쇄 원칙을 지킬 수 있도록 해준다.

객체지향설계(SOLID)

-   S: Single responsibility principle(SRP): 단일 책임 원칙 -> 한 클래스는 하나의 책임만 가져야 한다.
-   O: Open/Closed principle(OCP): 개방-폐쇄 원칙 -> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
-   L: Liskov substitution principle(LSP): 리스코프 치환 원칙 -> 프로그램의 객체는 프로그램의 정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
-   I: Interface segregation principle(ISP): 인터페이스 분리 원칙 -> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
-   D: Dependency inversion principle(DIP): 의존관계 역전 원칙 -> 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.

팩토리 패턴을 사용하지 않은 배 공장

```java
//Ship
public class Ship {
    private String name;
    private String color;
    private String logo;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }
    public String getLogo() {
        return logo;
    }
    public void setLogo(String logo) {
        this.logo = logo;
    }
    @Override
    public String toString() {
        return "Ship{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                ", logo='" + logo + '\'' +
                '}';
    }
}
```

```java
//ShipFactory
public class ShipFactory {

    public static Ship orderShip(String name, String email) {
        // validate
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }

        prepareFor(name);

        Ship ship = new Ship();
        ship.setName(name);

        // Customizing for specific name
        if (name.equalsIgnoreCase("whiteShip")) {
            ship.setLogo("\uD83D\uDEE5️");
        } else if (name.equalsIgnoreCase("whiteShip")) {
            ship.setLogo("⚓");
        }

        // coloring
        if (name.equalsIgnoreCase("whiteShip")) {
            ship.setColor("white");
        } else if (name.equalsIgnoreCase("whiteShip")) {
            ship.setColor("black");
        }

        // notify
        sendEmailTo(email, ship);

        return ship;
    }

    private static void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }

    private static void sendEmailTo(String email, Ship ship) {
        System.out.println(ship.getName() + " 다 만들었습니다.");
    }
}
```

```java
//Client
public class Client {
    public static void main(String[] args) {
        Ship whiteShip = ShipFactory.orderShip("WhiteShip", "keesun@mail.com");
        System.out.println(whiteShip);

        Ship blackShip = ShipFactory.orderShip("BlackShip", "keesun@mail.com");
        System.out.println(blackShip);
    }
}
```

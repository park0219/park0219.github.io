---
layout: post
title: "2022년 7월 TIL"
date: 2022-07-01 00:05:00 +0900
categories: 202207 TIL
---

### 7/1(금)

객체지향의 사실과 오해 - 3. 타입과 추상화  
객체지향과 추상화

[그룹으로 나누어 단순화하기]  
앨리스의 이야기에 등장하는 정원사, 병사, 신하, 왕자와 공주 등 각 인물들에게는 다양한 측면에서 서로를 구별할 수 있는 독특한 특징이 있다. 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물을 객체지향 패러다임에서는 **객체**라고 한다.  
앨리스의 이야기에 등장하는 정원사, 병사, 신하, 왕자와 공주 모두를 '트럼프'라고 줄여 부르기로 하자. 다양한 인물을 '트럼프'라는 한 단어로 줄여 지칭할 수 있는 이유는 해당 인물들이 공통적으로 '트럼프'라고 했을 때 떠오르는 일반적인 외형과 행동 방식을 가지고 있기 때문이다.

[개념]  
앨리스가 인물들의 차이점을 무시하고 공통점만 취해 트럼프라는 개념으로 단순화한 것은 추상화의 일종이다. 객체지향 패러다임의 중심에는 구체적이고 실제적인 객체가 존재하지만 수많은 객체들을 개별적인 단위로 취급하기에는 인간이 지닌 인지능력은 턱없이 부족하다. 따라서 사람들은 본능적으로 공통적인 특성을 기준으로 객체를 여러 그룹으로 묶어 동시에 다뤄야 하는 가짓수를 줄임으로써 상황을 단순화하려고 노력한다.  
이처럼 공통점을 기반으로 객체를 묶기 위한 그릇을 **개념(concept)**이라고 한다. 개념이란 일반적으로 우리가 인식하고 있는 아이디어나 관념을 뜻한다.  
개념을 이용하면 객체를 여러 그룹으로 **분류(classification)**할 수 있다. 개념은 공통점을 기반으로 객체를 분류할 수 있는 일종의 체라고 할 수 있다.  
각 객체는 특정한 개념을 표현하는 그룹의 일원으로 포함된다. 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 **인스턴스(instance)**라고 한다.

> 객체란?  
> 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

개념은 세상의 객체들을 거르는 데 사용하는 정신적인 렌즈를 제공한다. 이 렌즈를 통해 세상을 바라보면 수백 수천 개의 다양한 객체가 존재하는 복잡한 세상을 몇 개의 개념만으로 단순화할 수 있다. 개념은 객체를 분류할 수 있는 특을 제공하고, 주변의 복잡한 객체들은 단지 몇 가지 개념의 인스턴스일 뿐이다.

---

### 7/2(토)

객체지향의 사실과 오해 - 3. 타입과 추상화  
객체지향과 추상화

[개념의 세 가지 관점]  
개념은 특정한 객체가 어떤 그룹에 속할 것인지를 결정한다. 어떤 객체에 어떤 개념이 적용됐다고 할 때는 그 개념이 부가하는 의미를 만족시킴으로써 다른 객체와 함께 해당 개념의 일원이 됐다는 것을 의미한다.  
일반적으로 객체의 분류 장치로서 개념을 이야기할 때는 아래의 세 가지 관점을 함께 언급한다.

-   **심볼(symbol)**: 개념을 가리키는 간략한 이름이나 명칭
-   **내연(intension)**: 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
-   **외연(extension)**: 개념에 속하는 모든 객체의 집합(set)

심볼이란 개념을 가리키는 이름이다. 앨리스 이야기에서 개념을 지칭하는 데 사용하는 '트럼프'라는 이름은 개념의 심볼이 된다.  
내연이란 개념의 의미를 나타낸다. 앨리스 이야기에서 몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려 있다는 트럼프에 대한 설명이 바로 내연이다. 내연은 개념을 객체에게 적용할 수 있는지 여부를 판단하기 위한 조건이다.  
외연은 개념에 속하는 객체들, 즉 개념의 인스턴스들이 모여 이뤄진 집합을 가리킨다. 앨리스의 이야기에서 정원사, 병사, 신하, 왕자와 공주 등은 모두 트럼프의 외연을 구성하는 객체 집합에 속한다.  
트럼프 개념의 심볼, 내연, 외연

-   심볼: 트럼프
-   내연: 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물
-   외연: 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕

개념을 구성하는 심볼, 내연, 외연은 객체의 분류 방식에 대한 지침을 제공한다. 그러나 개념이 심볼, 내연, 외연으로 구성돼 있다는 사실보다는 개념을 이용해 객체를 분류할 수 있다는 사실이 더 중요하다. 개념을 이용해 공통점을 가진 객체들을 분류할 수 있다는 아이디어는 객체지향 패러다임이 복잡성을 극복하는 데 사용하는 가장 기본적인 인지 수단이기 때문이다.

객체지향의 세계에서 가장 널리 알려진 유명인사가 클래스(class)라는 사실을 감안한다면 분류(classification)라는 개념이 얼마나 중요한지 실감할 수 있을 것이다.

---

### 7/3(일)

객체지향의 사실과 오해 - 3. 타입과 추상화  
객체지향과 추상화

[객체를 분류하기 위한 틀]  
외연의 관점에서 어떤 객체에 어떤 개념을 적용할 수 있다는 것은 동일한 개념으로 구성된 객체 집합에 해당 객체를 포함시킨다는 것을 의미한다. 어떤 객체와 마주했을 때 객체에게 적용할 개념을 결정하는 것은 결국 해당 객체를 개념이 적용된 객체 집합의 일원으로 맞아들인다는 것을 의미한다. 어떤 객체가 개념에 적합하지 않을 경우 해당 객체는 해당 개념의 객체 집합에 포함되지 않을 것이다.  
따라서 분류란 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업을 의미한다.

> 분류란?
> 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다. 객체를 적절한 개념에 따라 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다. 객체는 소중하기 때문에 소중한 객체를 안전하고 적절한 장소에 보관할 수 있도록 개발자의 인지능력을 발휘해 최대한 직관적으로 분류해야 한다.

[분류는 추상화를 위한 도구다]  
앞에서 추상화는 두 가지 차원에서 이뤄진다고 했다. 추상화의 첫 번째 차원은 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 **일반화**를 통해 단순화하는 것이다. 추상화의 두 번째 차원은 중요한 부분을 강조하기 위해 **불필요한 세부 사항을 제거**해 단순화하는 것이다. 개념을 통해 객체를 분류하는 과정은 추상화의 두 가지 차원을 모두 사용한다.  
앞에서 정원사, 병사, 신하, 왕자와 공주 등을 트럼프라는 개념으로 묶은 것은 개별 객체 간의 차이점은 무시하고 공통점을 취한 결과다. 이는 추상화의 첫 번째 차원인 일반화를 적용한 결과다.  
트럼프에 속하는 객체들의 공통점 중에서도 우리가 중요하다고 생각하는 특징은 몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려 있다는 것뿐이다. 그 외의 사항들은 무시되고 있다. 이는 추상화의 두 번째 차원에 따라 불필요한 세부 사항을 제거했다고 볼 수 있다.  
개념은 객체들의 복잡성을 극복하기 위한 추상화 도구다. 그리고 오늘을 살아가는 우리는 매 순간 세상에 존재하는 무수한 사물들을 개념의 틀로 걸러가며 세상을 추상화한다. 추상화를 사용함으로써 우리는 극도로 복잡한 세상을 제어 가능한 수준으로 단순화할 수 있다.

---

### 7/4(월)

객체지향의 사실과 오해 - 3. 타입과 추상화  
타입

[타입은 개념이다]  
개념이라는 단어 자체는 이미 우리의 일상생활에서 폭넓게 사용되는 일상적인 용어지만 컴퓨터 공학자들은 **타입(type)**이라는 단어를 사용해 좀 더 세련되게 표현한다. 타입과 개념의 정의는 완전히 동일하다. 타입은 공통점을 기반으로 객체들을 묶기 위한 틀이다. 타입은 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술할 수 있으며 타입에 속하는 객체 역시 타입의 인스턴스라고 한다.

> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

[데이터 타입]  
사람이 어떤 일을 수행하기 위해서는 장기 기억 속에 묻혀진 기억의 편린들을 단기 기억 속으로 불러들여야만 하는 것처럼 컴퓨터가 어떤 작업을 수행하기 위해서는 작업에 필요한 데이터를 메모리 안으로 불러들여야 한다. 메모리에 불러들여진 데이터들은 무수히 많은 0과 1로 치장되어 메모리에 저장된다.  
메모리를 들여다 보면 그 안에는 끝없이 펼쳐진 0과 1의 행렬만이 존재한다. 메모리의 세상에는 타입이라는 질서가 존재하지 않는다. 실제로 '타입이 없다(Untyped)'는 말은 메모리 안의 데이터를 다룰 수 있는 단 하나의 타입만이 존재한다는 것을 의미한다. 모든 데이터는 일련의 비트열(bit string)로 구성된다. 어떤 메모리 조각에 들어 있는 값의 의미는 그 값을 가져다 자신의 용도에 맞게 사용하는 외부의 해석가, 흔히 애플리케이션이라고 부르는 프로그램에 의해 결정된다.  
타입 없는 무질서가 초래한 혼돈의 세상에 사람들은 메모리 안의 데이터에 특정한 의미를 부여하기 시작했다. 다뤄야 하는 데이터의 용도와 행동에 따라 그것들을 분류했다. 어떤 데이터에 다른 데이터를 더하거나 빼거나 나누거나 곱할 수 있다면 그 데이터를 숫자형으로 분류했다. 데이터가 여러 문자로 구성돼 있고 다른 문자와 연결할 수 있다면 그 데이터를 문자열형으로 분류했다. 데이터를 이용해 어떤 사실에 대한 참/거짓을 이야기할 수 있다면 그 데이터는 논리형으로 구분했다.  
컴퓨터 안에 살아가는 데이터를 목적에 따라 분류하기 시작히면서 **타입 시스템(type system)**이 자라나기 시작했다. 타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다. 타입 시스템은 메모리 안에 저장된 0과 1에 대해 수행 가능한 작업과 불가능한 작업을 구분함으로써 데이터가 잘못 사용되는 것을 방지한다. => 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.  
지금까지의 내용을 통해 타입에 관련된 두 가지 중요한 사실을 알 수 있다.  
첫째, 타입은 데이터가 어떻게 사용되느냐에 관한 것이다. 따라서 데이터가 어떤 타입에 속하는지를 결정하는 것은 데이터에 적용할 수 있는 작업이다. 일반적으로 데이터를 이용해 수행할 수 있는 작업을 연산자(operator)라고 한다. 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정한다.  
둘째, 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 데이터 타입의 표현은 연산 작업을 수행하기에 가장 효과적인 형태가 선택되며, 개발자는 해당 데이터의 타입의 표현 방식을 몰라도 뎅터를 사용하는 데 지장이 없다.

> 데이터 타입이란?  
> 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터이다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

---

### 7/5(화)

객체지향의 사실과 오해 - 3. 타입과 추상화  
타입

[객체와 타입]  
객체지향 프로그램을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다. 따라서 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다. 애플리케이션 내부에 살고 있는 모든 객체의 상태를 모으면 결국 애플리케이션에서 관리해야 하는 전체 데이터를 표현할 수 있게 된다.  
객체는 데이터가 아니고, 객체에서 중요한 것은 객체의 행동이다. 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다. 객체를 창조할 때 가장 중요하게 고려해야 하는 것은 **객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야 할지를 결정하는 것**이다. 즉 객체가 협을 위해 어떤 책임 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.  
객체의 타입의 두 가지 조건

-   첫째, 어떤 객체가 어떤 타입에 속하는 지를 결정하는 것은 객체가 수행하는 동작이다.  
    어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.
-   둘쨰, 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.  
    객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어던 방식으로 표현하더라도 무방하다.

[행동이 우선이다]  
동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다고 말할 수 있다. 이것은 객체를 타입으로 분류할 때 사용해야 하는 기준을 명확하게 제시한다. 어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준은 그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다. 그 객체가 다른 객체와 동일한 데이터를 가지고 있더라도 다른 행동을 한다면 그 객체들은 서로 다른 타입으로 분류되애 한다.  
타입이 데이터가 아니라 행동에 의해 결정된다는 사실은 객체지향 패러다임을 특징 짓는 중요한 몇 가지 원리와 원칙에 의미를 부여한다. 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 여기서 동일한 행동이란 동일한 책임을 의미하며, 동일한 책임이란 동일한 메시지 수신을 의미한다. 따라서 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다. 다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다. 이는 **다형성**에 의미를 부여한다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜨한다. 동일한 메시지를 서로 다른 방식으로 처리하기 위해서는 객체들은 동일한 메시지를 수신할 수 있어야 하기 때문에 결과적으로 다형적인 겍체들은 동일한 타입(또는 타입 계층)에 속하게 된다.  
데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다. 따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 이를 **캡슐화**라고 한다. 공용 인터페이스 뒤로 데이터를 캡슐화하라는 오래된 격언은 객체를 행동에 따라 분류하기 위해 지켜야 하는 기본적인 원칙이다.  
행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야 하는 데이터가 아니라 객체가 외부에 제공해야 하는 행동을 먼저 생각해야 한다. 이를 위해서는 객체가 외부에 제공해야 하는 책임을 먼저 결정하고 그 책임을 수행하는 데 적합한 데이터를 나중에 결정한 후, 데이터를 책임을 수행하는 데 필요한 외부 인터페이스 뒤로 캡슐화해야 한다. **책임-주도 설계(Responsibility-Driven Design)**라고 부르는 객체지향 설계 방법은 데이터를 먼저 생각하는 데이터-주도 설계(Data-Driven Design) 방법의 단점을 개선하기 위해 고안됐다.

**객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다.** 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.

---

### 7/6(수)

객체지향의 사실과 오해 - 3. 타입과 추상화  
타입의 계층

[트럼프 계층]  
앨리스의 이야기에 등장하는 정원사, 병사, 신하, 왕자와 공주를 '트럼프'라는 타입으로 분류했다. 해당 인물들은 카드 게임에서 사용하는 트럼프와 같다고 생각해서 분류한 것이 아니라 트럼프와 몇 가지 특징을 공유하기 때문에 트럼프라고 불렸던 것이다. 더 정확하게 말하면 앨리스는 등장인물들을 트럼프가 아니라 트럼프 인간으로 봤던 것이다.  
객체가 동일한 타입으로 분류되기 위해서는 공통의 행동을 가져야만 한다. 그러나 위 등장인물들의 외양은 트럼프와 유사하지만 행동 자체는 트럼프와 완벽하게 동일하지 않다.  
앞에서 트럼프 타입의 정의, 즉 내연을 납작 엎드릴 수 있고 뒤집어질 수 있으며 걸을 떄마다 몸이 종이처럼 좌우로 펄럭이는 존재로 정의했다. 일반적으로 트럼프 카드는 납작 엎드릴 수 있고 뒤집어질 수는 있지만 걸어다닐 수는 없다. 따라서 트럼프 타입으로 불렀던 객체들을 좀 더 정확하게 트럼프 인간이라는 타입으로 분류하는 것이 옳다. 트럼프 인간 타입의 객체는 트럼프 타입의 객체가 할 수 있는 모든 행동을 할 수 있을뿐만 아니라 추가적으로 걸어다니는 행동을 더 할 수 있다. => 트럼프 인간은 일반적인 트럼프 카드보다 좀 더 특화된 행동을 하는 트럼프이다.  
외연이라는 객체의 집합의 관점에서 트럼프와 트럼프 인간 타입을 봤을 때 트럼프 인간은 트럼프이다. 따라서 모든 트럼프 인간은 동시에 트럼프인 것이다. 이것은 트럼프 인간 타입에 속한 객체는 트럼프 타입의 객체에도 함께 속해야 한다는 것을 의미한다. 이 관점에서 트럼프는 트럼프 인간을 포괄하는 좀 더 일반적인 개념이다. 트럼프 인간은 트럼프보다 좀 더 특화된 행동을 하는 특수한 개념이다. 이 두 개념 사이의 관계를 **일반화/특수화(generalization/specialization)** 관계라고 한다.

[일반화/특수화 관계]  
타입과 타입 사이에는 일반화/특수화 관계가 존재할 수 있다. 더 일반적이라는 말은 더 포괄적이라는 의미를 내포하기 때문에 트럼프는 트럼프 인간에 속하는 객체를 포함한다.  
일반화와 특수화는 동시에 일어난다. 더 특수하다는 것은 일반적인 개념보다 범위가 더 좁다는 것을 의미하므로 트럼프 인간에 속한 객체는 트럼프에 속하는 객체보다 그 수가 적을 수밖에 없다. 집합의 관점에서는 특수한 개념을 포함하는 트럼프 인간은 좀 더 일반적인 개념을 표현하는 트럼프의 부분 집합이 된다.  
이때 중요한 것은 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이라는 것이다. 두 타입 간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 한다. 결국 객체의 일반화/특수화 관계에서도 중요한 것은 객체가 내부에 보관한 데이터가 아니라 객체가 외부에 제공하는 행동이다.  
행동의 관점에서 일반적인 타입이란 특수한 타입이 가진 행동들 중에서 일부 행동만을 가지는 타입을 가리킨다. 특수한 타입이란 일반적인 타입이 가진 모든 행동을 포함하지만 거기에 자신만의 행동을 추가하는 타입을 가리킨다. 따라서 일반적인 타입보다 특수한 타입이 더 많은 수의 행동을 가진다.  
여기서 주의해야 할 점은 타입의 내연을 의미하는 행동의 가짓수와 외연을 의미하는 집합의 크기는 서로 반대라는 사실이다. 일반화/특수화 관계에서 일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 더 큰 크기의 외연 집합을 가진다. 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가지지만 더 적은 크기의 외연 집합을 가진다.

---

### 7/7(목)

객체지향의 사실과 오해 - 3. 타입과 추상화  
타입의 계층

[슈퍼타입과 서브타입]  
일반화/특수화 관계는 좀 더 일반적인 한 타입과 좀 더 특수한 한 타입 간의 관게다. 이때 좀 더 일반적인 타입을 **슈터타입(Supertype)**이라고 하고 좀 더 특수한 타입을 **서브타입(Subtype)**이라고 한다.  
슈퍼타입과 서브타입 두 타입 간의 관계는 행동에 의해 결정된다. 즉 어떤 타입이 다른 타입의 서브 타입이 되기 위해서는 행위적 호환성을 만족시켜야 한다. 일반적으로 서브 타입은 슈퍼타입의 행위에 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 한다. 따라서 어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다.  
일반화/특수화 관계를 표기할 때는 일반적인 타입인 슈퍼타입을 상단에 좀 더 특수한 타입인 서브타입을 하단에 위치시키고 속이 빈 삼각형으로 연결해서 표현한다. 서브타입에서는 슈퍼타입과 중복된 행위를 생략할 수 있다.

[일반화는 추상화를 위한 도구다]  
추상화의 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거시켜 단순하게 만드는 것이다. 앨리스의 이야기에서 정원에 있는 등장인물을 트럼프 인간으로 추상화했다. 그러나 가끔씩은 트럼프 인간이 아니라 더 단순화된 트럼프로 보는 것이 상황을 더 단순하게 만드는 경우가 있다. 이때 앨리스는 트럼프 인간의 특수한 능력은 제거하고 트럼프의 특성에 집중한 것이다. 따라서 앨리스는 그 시점에 중요한 사항인 트럼프의 특성에만 집중하고 불필요한 트럼프 인간의 특성은 제거해 상황을 단순하게 만든 것이다.  
여기서 두 가지 추상화 기법이 사용되었다. 하나는 정원에 있던 등장인물들의 차이점을 배제하고 공통점만을 강조함으로써 이들을 공통의 타입인 트럼프 인간으로 분류한 것이고, 다른 하나는 트럼프 인간을 좀 더 단순한 관점에서 바라보기 위해 불필요한 특성을 배제하고 좀 더 포괄적인 의미를 가진 트럼프로 일반화했다는 것이다.  
이처럼 객체지향 패러다임을 통해 세상을 바라보는 거의 대부분의 경우에 분류와 일반화/특수화 기법을 동시에 적용하게 된다.

---

### 7/8(금)

객체지향의 사실과 오해 - 3. 타입과 추상화  
정적 모델

[타입의 목적]  
타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 너무 어렵기 때문이다.  
앨리스의 키는 앨리스가 어떤 행동을 할 때마다 시시각각 변한다. 그러나 앨리스라고 하는 객체의 상태는 변하지만 앨리스를 다른 객체와 구별할 수 있는 식별성은 동일하게 유지된다. 따라서 우리는 머싯속에 앨리스가 가질 수 있는 모든 경우의 키 값을 나열하는 대신 앨리스의 키가 임의의 값을 가질 수 있다는 사실만을 생각함으로써 상황을 단순하게 만들 수 있다.  
타입은 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. 결국 타입은 앨리스의 상태에 복잡성을 부과하는 시간이라는 요소를 제거함으로써 시간에 독립적인 정적인 모습으로 앨리스를 생각할 수 있게 해준다.

[그래서 결국 타입은 추상화다]  
추상화를 사용하면 어떤 시점에 앨리스에 관해 생각할 때 불필요한 시간이라는 요소와 상태 변화라는 요소를 제거하고 철저하게 정적인 관점에서 앨리스의 모습을 묘사하는 것을 가능하게 해준다.  
타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다.

[동적 모델과 정적 모델]  
객체에는 두 가지 모델을 동시에 고려한다.  
하나는 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐다. 이를 객체의 **스냅샷(snapshot)**이라고 한다. 객체지향 모델링을 위한 표준 언어인 UML에서 스냅샷은 **객체 다이어그램(object diagram)**이라고도 불린다. 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것은 **동적 모델(dynamic model)**이라고 한다.  
다른 하나는 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것이다. 일반적으로 이런 모델을 **타입 모델(type diagram)**이라고 한다. 이 모델은 동적으로 변하는 객체의 상태가 아니라 객체가 속한 타입의 정적인 모습을 표현하기 때문에 **정적 모델(static model)**이라고도 한다.  
객체지향 프로그래밍 언어를 이용해 클래스를 작성하는 시점에는 시스템을 정적인 관점에서 접근하는 것이다. 그러나 실제로 애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 동안에는 객체의 동적인 모델을 탐험하고 있는 것이다.

[클래스]  
객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 따라서 **타입을 구현**하는 가장 보편적인 방법은 클래스를 이용하는 것이다. 클래스와 타입은 동일한 것이 아니다. 타입은 객체를 분류하기 위해 사용하는 개념이고, 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나이다. 자바스크립트와 같은 프로토타입 기반의 언어에는 클래스가 존재하지 않는다.  
그럼에도 대부분의 객체지향 프로그래밍 언어는 클래스를 기반으로 하기 때문에 많은 사람들은 클래스와 타입을 동일한 개념이라고 생각한다. 클래스와 타입을 구분하는 것은 설계를 유연하게 유지하기 위한 바탕이 된다. 클래스는 타입의 구현 외에도 코드를 재사용하는 용도로도 사용되기 때문에 클래스와 타입을 동일시하는 것은 수많은 오해와 혼란을 불러일으키곤 한다.  
객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다. 그리고 객체를 분류하기 위해 타입을 결정한 후 프로그램 언어를 이용해 타입을 구현할 수 있는 한 가지 방법으로 클래스가 있다.  
객체지향에서 중요한 것은 동적으로 변하는 객체의 **상태**와 상태를 변경하는 **행위**다.

---

### 7/9(토)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
역할, 책임, 협력

인간의 행동을 결정하는 것은 인간이 어떤 본질적인 특징을 지니고 있느냐가 아니라 어떤 상황에 처해 있느냐이다. 즉, 각 개인이 처해 있는 정황 또는 문맥(context)이 인간의 행동 방식을 결정한다. 협력에 얼마나 적절한지에 따라 행동의 적합성이 결정되며 협력이라는 문맥이 인간의 행동 방식을 결정한다.  
객체의 세계에서도 협력이라는 문맥이 객체의 행동 방식을 결정한다. 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력이다. 객체지향 설계의 전체적인 품질을 결정하는 것은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질이다. 협력이 자리를 잡으면 저절로 객체의 행동이 드러나고 뒤이어 적절한 객체의 상태가 결정된다.  
훌륭한 객체지향 설계는 하나의 객체를 따로 떼어놓고 봤을 때는 겉모습이 다소 기묘하고 비합리적이라도 조화를 이루며 적극적으로 상호작용하는 협력적인 객체를 창조하는 것이다.  
객체의 모양을 빚는 것은 객체가 참여하는 협력이다. 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.

---

### 7/10(일)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
협력

[요청하고 응답하며 협력하는 사람들]  
일상생활 속에서 이뤄지는 협력의 본질은 요청과 응답으로 연결되는 사람들의 네트워크다. 우리가 직면하게 되는 문제는 혼자만의 힘으로는 해결하기 어렵기 때문에 해결 과정에 여러 사람이 참여하게 되고 이 과정에서 요청과 응답의 연쇄적인 흐름이 발생한다.  
**협력**은 한 사람이 다른 사람에게 도움을 **요청**할 때 시작된다. 요청을 받은 사람은 일을 처리한 후 요청한 사람에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 **응답**한다.  
다른 사람으로부터 요청을 받은 사람 역시 자신에게 주어진 일을 처리하던 중 다른 사람의 도움이 필요한 경우가 있다. 결과적으로 협력은 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.

[누가 파이를 훔쳤지?]  
객체지향의 세계는 동일한 목적을 달성하기 위해 협력하는 객체들의 공동체라는 사실을 기억하라. 객체지향 관점에서 앨리스의 이야기 중 재판 장면에 등장하는 모든 등장인물은 객체다. 객체들은 재판하기 위해 서로 협력하고 있다. 즉, 이야기에 등장하는 객체들은 동일한 목적을 달성하기 위해 협력하고 있는 것이다.

[재판 속의 협력]  
어떤 등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다. 그리고 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

---

### 7/11(월)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
책임

객체지향의 세계에서는 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 **책임**을 가진다고 말한다. 크레이그 라만은 "객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것"이라고 말한다.

[책임의 분류]  
협력에 참여하는 객체들은 목표를 달성하는 데 필요한 책임을 수행한다. 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 알아야 하는 정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다. 즉 객체의 책임은 '객체가 무엇을 알고 있는가(knowing)'와 '무엇을 할 수 있는가(doing)'로 구성된다.

-   하는 것(doing)
    -   객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    -   다른 객체의 행동을 시작시키는 것
    -   다른 객체의 활동을 제어하고 조절하는 것
-   아는 것(knowing)
    -   개인적인 정보에 관해 아는 것
    -   관련된 객체에 관해 아는 것
    -   자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소다. 명확한 책임이 애플리케이션의 미래를 결정 짓는다.  
객체의 책임을 이야기 할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다. 즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다. 따라서 책임은 객체의 **공용 인터페이스(public interface)**를 구성한다.

[책임과 메시지]  
협력 안에서 객체는 다른 객체로부터 요청이 전송됐을 경우에만 자신에게 주어진 책임을 수행한다. 결국 한 객체가 다른 객체에게 전송한 요청은 그 요청을 수신한 객체의 책임이 수행되게 한다. 이처럼 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 **메시지 전송(message-send)**이라고 한다. 메시지를 전송함으로써 협력을 요청하는 객체를 **송신사**라고 하고 메시지를 받아 요청을 처리하는 객체를 **수신자**라고 한다. 메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 수단이다.  
책임이 협력이라는 문맥 속에서 요청을 수신하는 한 쪽의 객체 관점에서 무엇을 할 수 있는지를 나열하는 것이라면 메시지는 협력에 참여하는 두 객체 사이의 관계를 강조한 것이다. 메시지라고 이야기할 떄는 항상 메시지를 전송하는 객체와 메시지를 수신하는 객체가 상호 협력하는 문맥을 강조한다.  
이때 주의할 점은 책임과 메시지의 수준이 같지 않다는 점이다.책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.  
객체지향 설게는 **협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작**된다. 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.

---

### 7/12(화)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
역할

[첵임의 집합이 의미하는 것]  
어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다. 역할은 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이다.

[역할이 답이다]  
앨리스의 이야기에서 서로 다른 세 개의 재판 과정, 즉 세 개의 협력이 주어져 있다. 참여하는 등장인물들을 제외한 나머지 과정이 너무나도 유사해서 하나의 협력으로 다루고자 한다. **역할(role)**을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.  
역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다. 협력 안에서 역할은 "이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다."라고 말하는 것과 같다.  
그러나 모든 객체가 특정 역할을 대체할 수는 없다. 역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다. 따라서 **역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체**로 한정된다.  
동일한 역할을 수행할 수 있다는 것은 해당 객체들이 협력 내에서 동일한 책임의 집합을 수행할 수 있다는 것을 의미한다.  
역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다. 또한 다양한 객체들이 협력에 참여할 수 있기 때문에 협력이 좀 더 유연해지며 다양한 객체들이 동일한 협력에 참여할 수 있기 때문에 재사용성이 높아진다. 역할은 객체지향 설계의 **단순성(simplicity)**, **유연성(flexibility)**, **재사용성(reusability)**을 뒷받침하는 핵심 개념이다.

[협력의 추상화]  
역할의 가장 큰 가치는 **하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것**이다. 이르르 통해 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다.  
구체적인 객체로 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력은 과거의 전통적인 패러다임과 구분되는 객체지향만의 힘이다.

[대체 가능성]  
역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자다. 따라서 본질적으로 역할은 다른 객체에 의해 대체 가능함을 의미한다.  
객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다는 점이 중요하다. 객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 **모든 책임**을 동일하게 수행할 수 있어야 한다.  
객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다. 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. 따라서 대부분의 경우에 객체의 타입과 역할 사이에는 **일반화/특수화 관계**가 성립한다. 일반화/특수화 관점에서 좀 더 일반적인 개념을 의미하는 역할은 일반화이며 좀 더 구체적인 개념을 의미하는 객체의 타입은 특수화이다. 역할이 협력을 추상적으로 만들 수 있는 이유는 역할 자체가 객체의 추상화이기 때문이다.

**역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.**

---

### 7/13(수)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
객체의 모양을 결정하는 협력

[흔한 오류]
많은 사람들은 객체가 시스템에 필요한 데이터를 저장하기 위해 존재한다고 생각하지만 객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다. 따라서 실제로 중요한 것은 객체의 행동, 즉 책임이다.  
또한, 사람들은 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다. 그러나 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체이며, 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 메커니즘이라는 사실이다.
객체지향 입문자들이 데이터나 클래스를 중심으로 애플리케이션을 설계하는 이유는 협력이라는 문맥을 고려하지 않고 각 객체를 독립적으로 바라보기 때문이다. 실제로 동작하는 애플리케이션을 구축하기 위해서는 협력을 우선적으로 고려해야 한다.

[협력을 따라 흐르는 객체의 책임]  
올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 설계해야 한다. 협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것을 의미한다. 이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행할 책임이 된다.  
객체에게 책임을 할당하면 책임은 객체가 외부에 제공하게 될 행동이 된다. 협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 그 행동을 수행하는 데 필요한 데이터를 고민해야 한다. 그리고 객체가 협력에 참여하기 위해 필요한 데이터와 행동이 어느 정도 결정된 후에 클래스의 구현 방법을 결정해야 한다. **클래스와 데이터는 협력과 책임이 결정된 후에야 무대 위에 등장할 수 있다.**  
협력이라는 견고한 문맥이 갖춰지면 초점은 협력을 위해 필요한 책임으로 넘어간다. 그리고 협력에 필요한 책임을 결정하고 깨체에게 책임을 할당하는 과정을 합리적이고 적절하게 수행함으로써 객체지향 설계의 품질을 높일 수 있다.  
객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 창조하는 것이다. **객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만드는 것**이 중요하다.

---

### 7/14(목)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
객체지향의 설계 기법

1. **책임 주도 설계(Responsibility-Driven Design)** 방법은 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다. 책임-주도 설계 방법은 객체지향 패러다임의 전문가들이 애플리케이션을 개발할 때 어떤 방식으로 사고하고 무엇을 기반으로 의사결정을 내리는지 잘 보여준다.
2. **디자인 패턴(Design Pattern)**은 전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음이다. 패턴은 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음이다.
3. **테스트-주도 개발(Test-Driven Development)**은 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식을 따른다. 테스트-주도 개발의 핵심은 테스트 작성이 아니라 구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별하고 식별된 역할, 책임, 협력이 적합한지를 피드백받는 것이다.

[책임-주도 설계]  
객체지향 시스템은 역할과 책임을 수행하는 자율적인 객체들의 공동체다. 객체지향 시스템의 목적은 사용자의 요구를 만족시킬 수 있는 기능을 제공하는 동시에 이해하기 쉽고, 단순하며, 유연한 상호작용을 제공하는 객체들의 공동체를 구축하는 것이다.  
객체지향 설계란 애플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정이다.  
객체지향 설계의 핵심은 올바른 책임을 올바른 객체에게 할당하는 것이다. 프로그래밍 과정에서 객체지향 언어를 사용하거나 UML과 같은 모델링 언어를 이용해 설계의 밑그림을 그린다고 해서 효율적이고 견고한 객체지향 시스템이 보장되는 것은 아니다. 이를 위해서는 전체 개발 단계에 걸쳐 객체의 역할과 책임, 협력을 도드라지게 만드는 기법과 체계를 따르는 것이 중요하다.  
현재 가장 널리 받아들여지는 객체지향 설계 방법은 레베카 워프스브록이 고안한 책임-주도 설계 방법이다. 말 그대로 객체의 책임을 중심으로 시스템을 구축하는 설계 방법을 말한다.  
시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다. 객체가 책임을 수행하는 도중에 스스로 처리할 수 없는 정보나 기능이 필요한 경우 적절한 객체를 찾아 필요한 작업을 요청한다. 요청된 작업을 수행하는 일은 이제 작업을 위임받은 객체의 책임으로 변환된다. 객체가 다른 객체에게 작업을 요청하는 행위를 통해 결과적으로 객체들 간의 협력 관계가 만들어진다. 만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.  
책임-주도 설계에서는 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체를 구축한다. 책임-주도 설계는 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중한다. 결과적으로 시스템은 스스로 자신을 책임질 수 있을 정도로 충분히 자율적인 동시에 다른 객체와 우호적으로 협력할 수 있을 정도로 충분히 협조적인 객체들로 이뤄진 생태계를 구성하게 된다.  
객체지향 시스템을 설계하는 절차:

-   시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
-   시스템 책임을 더 작은 책임으로 분할한다.
-   분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
-   객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
-   해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

**역할, 책임, 협력**은 유연하고 견고한 객체지향 시스템을 만드는 데 필요한 가장 중요한 재료다.

---

### 7/15(금)

객체지향의 사실과 오해 - 4. 역할, 책임, 협력  
객체지향의 설계 기법

[디자인 패턴]  
디자인 패턴은 책임-주도 설계의 결과를 표현한다. 패턴은 모범이 되는 설계로, 특정한 상황에서 설계를 돕기 위해 모방하고 수정할 수 있는 과거의 설계 경험이다.  
일반적으로 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법이 쌍으로 정의된다. 패턴은 해결하려고 하는 문제가 무엇인지를 명확하게 서술하고, 패턴을 적용할 수 있는 상황과 적용할 수 없는 상황을 함께 설명한다.  
디자인 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 디자인 패턴을 활용한다면 책임-주도 설계의 절차를 순차적으로 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 포착할 수 있을 것이다.

[테스트-주도 개발]  
테스트-주도 개발의 기본 흐름은 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후(이 시간 동안에는 중복이 있어도 무방하다), 리팩터링(refactoring)을 통해 중복을 제거하는 것이다. 이를 통해 '작동하는 깔끔한 코드(clean code that works)'를 얻을 수 있다.  
테스트-주도 개발이 응집도 높고 결합도가 낮은 클래스로 구성된 시스템을 개발할 수 있게 하는 최상의 프랙티스인 것은 맞니만 객체지향에 대한 경험이 적은 초보자들은 개발을 주도하기 위해 어떤 테스트를 어떤 식으로 작성해야 하는지를 결정하는 데 큰 어려움을 느낀다. 테스트-주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다.  
테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.  
테스트-주도 개발은 책임-주도 설계의 기본 개념을 따른다. 테스트-주도 개발은 책임-주도 설계를 통해 도달해야 하는 목적지를 테스트라는 안전장치를 통해 좀 더 빠르고 견고한 방법으로 도달할 수 있도록 해주는 최상의 설계 프랙티스다.  
테스트를 작성하기 위해 객체의 메서드를 호출하고 반환값을 검증하는 것은 순간적으로 객체가 수행해야 하는 책임에 관해 생각한 것이다. 테스트에 필요한 간접 입력 값을 제공하기 위해 스텀(stub)을 추가하거나 간접 출력 값을 검증하기 위해 목 객체(mock object)를 사용하는 것은 객체와 협력해야 하는 협력자에 대해 고민한 결과를 코드로 표현한 것이다.  
테스트-주도 개발은 책임-주도 설계의 기본 개념과 다양한 원칙과 프랙티스, 패턴을 종합적으로 이해하고 좋은 설계에 대한 감각과 경험을 길러야만 적용할 수 있는 설계 기법이다. 역할, 책임, 협력에 집중하고 객체지향의 원칙을 적용하려는 깊이 있는 고민과 노력을 통해서만 테스트-주도 개발의 혜택을 누릴 수 있다.

역할, 책임, 협력의 개념을 통해 객체지향 패러다임이 다른 전통적인 패러다임에 비해 우월한 이유는 책임과 메시지에 숨겨져 있다.

---

### 7/16(토)

객체지향의 사실과 오해 - 5. 책임과 메시지  
자율적인 책임

> 의도는 "메시징"이다. 휼륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤티케이션 하는가에 달려 있다. - 앨런 케이

[설계의 품질을 좌우하는 책임]  
객체지향 공동체를 구성하는 기본 단위는 '자율적'인 객체다. 객체들은 애플리케이션의 기능을 구현하기 위해 협력하고, 협력 과정에서 각자 맡은 바 책임을 다하기 위해 자율적으로 판단하고 행동한다.  
여기서 키워드는 '자율성'이다. 자율성의 사전적 의미는 '자기 스스로의 원칙에 따라 어떤 일을 하거나 자신을 통제해서 절제하는 성질이나 특성'이다. 반대말인 타율성은 '자신의 의지와 관계없이 정해진 규율이나 원칙에 따라서만 움직이는 성질'을 의미한다. 따라서 자율적인 객체란 **스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체**다.  
객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. 요청을 처리하기 위해 객체가 수행하는 행동을 **책임**이라고 한다. 따라서 자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체를 의미한다.  
적절한 책임의 선택이 전체 설계의 방향을 결정한다. 적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다.

[자신의 의지에 따라 증언할 수 있는 자유]  
객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다. 책임이 자율적이지 않다면 객체가 아무리 발버둥친다고 하더라도 자율적으로 책임을 수행하기 어렵다.

[너무 추상적인 책임]  
포괄적이고 추상적인 책임을 선택한다고 해서 무조건 좋은 것은 아니다. 책임이 수행 방법을 제한할 정도로 너무 구체적인 것도 문제지만 협력의 의도를 명확하게 표현하지 못할 정도로 추상적인 것 역시 문제다.  
추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 사용할 수 있도록 유연성이라는 축복을 내려준다. 그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.  
어떤 책임이 자율적인지를 판단하는 기준은 문맥에 따라 다르다. 성급한 일반화의 오류를 피하고 현재 문맥에 가장 적합한 책임을 선택할 수 있도록 노력해야 한다.

['어떻게'가 아니라 '무엇'을]  
자율적인 책임의 특징은 객체가 '어떻게(how)'해야 하는가가 아니라 '무엇(what)'을 해야 하는가를 설명한다는 것이다. 책임은 '무엇'을 해야 하는지를 결정하지만 '어떻게' 해야 하는지에 대해 전혀 언급하지 않는다. 이를 통해 객체를 자율적으로 행동을 결정할 수 있다.

[책임을 자극하는 메시지]  
책임이라는 말 속에는 어떤 행동을 수행한다는 의미가 포함돼 있다. 객체지향 공동체 안에 거주하는 객체는 다른 객체로부터 전송된 요청을 수신할 때만 어떤 행동을 시작한다. 따라서 객체가 자신에게 할당된 책임을 수행하도록 만드는 것은 외부에서 전달되는 요청이다.  
객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐이고, 이 요청을 메시지라고 부른다. 메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.

---

### 7/17(일)

객체지향의 사실과 오해 - 5. 책임과 메시지  
메시지와 메서드

[메시지]  
하나의 객체는 메시지를 전송함으로써 다른 객체에 접근한다. 사용자에 대한 객체의 독립성과 객체지향 개념을 구현한 초기 언어들의 일부 문법 때문에 객체의 행동을 유발하는 행위를 가리켜 **메시지-전송**이라고 한다.  
메시지에서 행동을 나타내는 부분(오퍼레이션)을 **메시지 이름(message name)**이라고 한다. 메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 **인자(argument)**를 통해 추가 정보를 제공할 수 있다. 수신자는 메시지를 처리하기 위해 메시지에 실려 있는 인자를 사용할 수 있다. 메시지 전송은 수신자, 메시지 이름, 인자의 조합이 된다.  
송신자는 메시지 전송을 통해서만 다른 객체의 책임을 요청할 수 있고, 수신자는 오직 메시지 수신을 통해서만 자신의 책임을 수행할 수 있다.  
메시지의 수신자는 메시지를 수신했을 때 이를 처리하는 방법을 자유롭게 선택할 수 있다. 이것은 객체의 외부와 내부가 메시지를 기준으로 분리된다는 것을 의미한다.  
메시지는 객체들이 서로 협력하기 위해 사용할 수 있는 유일한 의사소통 수단으로, 객체가 메시지를 수신할 수 있다는 것은 객체가 메시지에 해당하는 책임을 수행할 수 있다는 것을 의미한다. 객체가 유일하게 이해하고 의사소통할 수 있는 수단은 메시지 뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다. 외부의 객체는 메시지에 관해서만 볼 수 있고 객체 내부는 볼 수 없기 때문에 자연스럽게 객체의 외부와 내부가 분리된다.

[메서드]  
객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 **메서드**라고 한다. 객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 여부를 확인한다. 메시지를 처리할 수 있다고 판단되면 자신에게 주어진 책임을 다하기 위해 메시지를 처리할 방법인 메서드를 선택하게 된다.  
메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나다.

[다형성]  
다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘을 말한다.  
메시지에는 처리 방법과 관련된 어떤 제약도 없기 때문에 동일한 메시지라고 하더라도 다른 메서드를 이용해 처리할 수 있다. 따라서 다형성을 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있다.  
다형성은 역할, 책임, 협력과 깊은 관련이 있다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. 다형성에서 중요한 것은 메시지 송신자의 관점이다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것이다. 즉, 송신자의 관점에서 다형적인 수신자들은 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일하다.  
다형성은 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 한다. 어떤 객체라도 전송한 메시지를 처리할 수 있다면 상관없기 때문이다.  
다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 **대체 가능성**을 의미한다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. 즉, 다형성은 숫니의 종류를 캡슐화한다.  
다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 낮춤으로써 달성된다.

[유연하고 확장 가능하고 재사용성이 높은 협력의 의미]  
송신자가 수신자에 대해 매우 적은 정보만 알고 있다라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.  
첫째, 협력이 유연해진다. 송신자는 수신자가 메시지를 이해한다면 누구라도 상관하지 않는다. 따라서 송신자에 대한 파급효과 없이 유연하게 협력을 변경할 수 있다.  
둘쨰, 협력이 수행되는 방식을 확장할 수 있다. 송신자에게 아무런 영향도 미치지 않고서도 수신자를 교체할 수 있기 때문에 협력의 세부적인 수행 방식을 쉽게 수정할 수 있다.  
셋째, 협력이 수행되는 방식을 재사용할 수 있다. 협력에 영향을 미치지 않고서도 다양한 객체들이 수신자의 자리를 대체할 수 있기 때문에 다양한 문맥에서 협력을 재사용할 수 있다.

[송신자와 수신자를 약하게 연결하는 메시지]  
메시지는 송신자와 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만든다. 송신자는 오직 메시지만 바라본다. 수신자의 정확한 타입을 모르더라도 상관없다. 수신자는 메시지를 처리하기 위해 자율적으로 메서드를 선택할 수 있지만 메서드 자체는 송신자에게 노출하지 않는다.

---

### 7/18(월)

객체지향의 사실과 오해 - 5. 책임과 메시지  
메시지를 따라라

[객체지향의 핵심, 메시지]  
객체지향의 기본 개념은 책임을 수행하는 자율적인 객체들의 협력을 통해 애플리케이션을 구축하는 것이다. 객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.  
객체지향 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의된다. 실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 객체다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지다.  
메시지가 아니라 데이터를 중심으로 객체를 설계하는 방식은 객체의 내부 구조를 객체 정의의 일부로 만들기 때문에 객체의 자율성을 저해한다. 이와 같은 접근 방법을 **데이터-주도 설계**라고 부른다.  
훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다. 객체지향 설계의 중심에는 메시지가 위치한다.

[책임-주도 설계 다시 살펴보기]  
객체지향 설계는 적절한 책임을 적절한 객체에게 할당하면서 메시지를 기반으로 협력하는 객체들의 관계를 발견하는 과정이다. 이처럼 책임을 완수하기 위해 협력하는 객체들을 이용해 시스템을 설계하는 방법을 **책임-주도 설계**라고 한다.  
책임-주도 설계 방법에서 역할, 책임, 협력을 식별하는 것은 애플리케이션이 수행하는 기능을 시스템의 책임으로 보는 것으로 부터 시작된다. 시스템이 수행할 책임을 구현하기 위해 협력 관계를 시작할 적절한 객체를 찾아 시스템의 책임을 객체의 책임으로 할당한다. 객체가 책임을 완수하기 위해 다른 객체의 도움이 필요하다고 판단되면 도움을 요청하기 위해 어떤 **메시지가 핃요한지 결정**한다. 메시지를 결정한 후에는 메시지를 수신하기에 적합한 **객체를 선택**한다. 수신자는 송신자가 기대한 대로 메시지를 처리할 책임이 있다. 결과적으로 **메시지가 수신자의 책임을 결정**한다.

[What/Who 사이클]  
책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다. 이 과정을 흔히 **What/Who 사이클**이라고 한다. What/Who 사이클이라는 용어가 의미하는 것은 객체 사이의 협력 관계를 설계하기 위해서는 먼저 '어떤 행위(what)'를 수행할 것인지를 결정한 후에 '누가(who)' 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 어떤 행위가 메시지를 의미한다.  
협력이라는 문맥안에서 객체의 책임을 결정하는 것은 메시지다. 책임이 먼저 오고 객체가 책임을 따른다. 결과적으로 시스템이 수행해야 하는 전체 행위는 협력하는 객체들의 책임으로 분배된다.  
What/Who 사이클이라는 용어는 역할을 수행할 객체의 인터페이스를 발견하기 위해 메시지를 이용하는 책임-주도 설계의 핵심 아이디어를 명확하게 표현한다.  
메시지를 통한 '인터페이스 발견(interface discovery)'은 테스트-주도 설계 방법을 이용해 객체를 설계할 때 핵심이 되는 아이디어다.

[묻지 말고 시켜라]  
메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 한다. 이 스타일을 **묻지 말고 시켜라(Tell, Don't Ask)** 스타일 또는 **데메테르 법칙(Law of Demeter)**이라고 한다.  
메시지를 결정하는 시점에서는 어떤 객체가 메시지를 수신할 것인지를 알 수 없기 때문에 당연히 메시지 송신자는 메시지를 수신할 객체의 내부 상태를 볼 수 없다. 따라서 메시지 중심의 설계는 메시지 수신자의 캡슐화를 증진시킨다. 또한, 송신자가 수신자의 내부 상태를 미리 알 수 없기 때문에 송신자와 수신자가 느슨하게 결합된다.  
송신자는 수신자가 어떤 객체인지 모르기 때문에 객체에 관해 캐물을 수 없다. 이런 협력 패턴을 '묻지 말고 시켜라'라는 이름으로 부른다.  
'묻지 말고 시켜라' 스타일은 객체지향 애플리케이션이 자율적인 객체들의 공동체라는 사실을 강조한다. 객체는 다른 객체의 결정에 간섭하지 말아야 하며, 모든 객체는 자신의 상태를 기반으로 스스로 결정을 내려야 한다.  
객체는 다른 객체의 상태를 묻지 말아야 한다. 필요한 메시지를 전송하기만 하고 메시지를 수신하는 객체가 스스로 메시지의 처리 방법을 결정하게 해야 한다.  
샌디 메츠(Sandi Metz)는 '문지 말고 시켜라' 스타일이란 "메시지가 '어떻게' 해야 하는지를 지시하지 말고 '무엇'을 해야 하는지를 요청"하는 것이라고 설명한다. '어떻게'에서 무엇'으로 전환하는 것은 객체 인터페이스의 크기를 급격하게 감소시킨다. 이는 메시지 송신자와 수신자 간의 결합도를 낮춰준다.

[메시지를 믿어라]  
객체지향 시스템은 협력하는 객체들의 연결망이다. 전체 시스템은 메시지를 전송하는 객체와 전송된 메시지를 이해할 수 있는 객체를 연결하고 상호 관련짓는 과정을 통해 구축된다.  
메시지를 기반으로 다양한 타입의 객체들이 동일한 협력 과정에 참여할 수 있기 때문에 다양한 상황에서 협력을 재사용할 수 있다. 메시지를 중심으로 설계된 구조는 유연하고 확장 가능하며 재사용 가능하다.

---

### 7/19(화)

객체지향의 사실과 오해 - 5. 책임과 메시지  
객체 인터페이스

[인터페이스]  
일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다. 개발자는 미리 약속된 애플리케이션 프로그래밍 인터페이스(application programming interface)를 통해 다른 사람이 작성한 코드와 상호작용한다.  
인터페이스는 세 가지 특징을 가진다.

1.  인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
2.  인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
3.  대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 어무런 문제 없이 상호작용할 수 있다.

[메시지가 인터페이스를 결정한다]  
객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 빚는다.

[공용 인터페이스]  
인터페이스는 외부에서 접근 가능한 공개된 인터페이스와 내부에서만 접근할 수 있는 감춰진 인터페이스로 구분된다. 내부에서만 접근 가능한 사적인 인터페이스와 구분하기 위해 외부에 공개된 인터페이스를 **공용 인터페이스**라고 한다.  
객체지향 패러다임 안에서는 자기 스스로에게 뭔가를 요청하는 경우에도 메시지를 전송해야 한다.  
객체가 협력에 참여하기 위해 수행하는 메시지가 객체의 공용 인터페이스의 모양을 암시한다. 앞에서 설명한 책임-주도 설계 방식의 What/Who 사이클과 관련이 깊다. 먼저 메시지를 결정하고 이 메시지를 수행할 객체를 나중에 결정하기 때문에 메시지가 수신자의 인터페이스를 결정할 수밖에 없다.

[책임, 메시지, 그리고 인터페이스]  
협력에 참여하는 객체는 자율적이어야 한다. 여기서 자율성이란 자신의 의지와 판단력을 기반으로 객체 스스로 책임을 수행하는 방법을 결정할 수 있음을 의미한다.  
한 객체가 다른 객체에게 요청을 전송할 때는 메시지만을 사용한다. 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 채워진다. 객체가 메시지를 수신했을 때 적절한 객체의 책임이 수행된다. 메서드란 메시지를 수신했을 때 책임을 수행하는 방법을 의미한다. 메시지와 메서드의 구분은 객체를 외부와 내부라는 두 개의 명확하게 분리된 영역으로 구분하는 동시에 다형성을 통해 다양한 타입의 객체를 수용할 수 있는 유연성을 부과한다.  
인터페이스는 객체가 책임을 수행하기 위해 외부로부터 메시지는 받기 위한 통로다. 인퍼페이스는 객체가 다른 객체와 협력하기 위한 접점이다. 객체는 다른 객체로부터 메시지를 받아야만 자신에게 할당된 책임을 수행할 수 있다. 객체가 어떤 메시지를 수신할 수 있느냐가 어떤 책임을 수행할 수 있느냐와 어떤 인터페이스를 가질 것인지를 결정한다.  
메시지로 구성된 공용 인터페이스는 객체의 외부와 내부를 명확하게 분리한다. 객체지향의 힘은 대부분 객체의 외부와 내부를 구분하는 것에서 나온다.

---

### 7/20(수)

객체지향의 사실과 오해 - 5. 책임과 메시지  
인터페이스와 구현의 분리

[객체의 관점에서 생각하는 방법]  
맷 와이스펠트는 객체지향적인 사고 방식을 이해하기 위해서는 다음의 세 가지 원칙이 중요하다고 주장한다.

1. 좀 더 추상적인 인터페이스
2. 최소 인터페이스
3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

첫 번쨰 원칙인 좀 더 추상적인 인터페이스는 자율적인 책임을 다루며 살펴봤다. 지나치게 상세한 수준의 메시지를 보내는 것은 객체의 자율성을 저해한다. 대신 좀 더 추상적인 수준의 메시지를 수신할 수 있는 인터페이스를 제공하면 수신자의 자율성을 보장할 수 있다.  
두 번째 원칙인 최소 인터페이스(minimal interface) 주의는 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말하는 것이다. 인터페이스를 최소로 유지하면 객체의 내부 동작에 대해 가능한 적은 정보만 외부에 노출할 수 있다. 따라서 객체의 내부를 수정하더라도 외부에 미치는 영향을 줄일 수 있다. 최소 인터페이스는 메시지를 먼저 결정하고 객체를 나중에 선택하는 책임-주도 설계 방법을 따를 때 달성할 수 있다.  
마지막 원칙은 아래 설명으로 이어진다.

[구현]
객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현(implementation)이다. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.  
객체는 상태를 가진다. 상태는 어떤 식으로든 객체에 포함되겠지만 객체 외부에 노출되는 공용 인터페이스의 일부는 아니다. 따라서 상태를 어떻게 표현할 것인가는 객체의 구현에 해당한다.  
객체는 행동을 가진다. 행동은 메시지를 수신했을 때만 실행되는 일종의 메시지 처리 방법이다. 이를 메서드라고 부르며 메서드를 구성하는 코드 자체는 객체 외부에 노출되는 공용 인터페이스의 일부는 아니기 때문에 객체의 구현 부분에 포함된다.

[인터페이스와 구현의 분리 원칙]  
휼륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 이것은 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확하게 분리해서 고려해야 한다는 것을 의미한다. 이를 **인터페이스와 구현의 분리(separation of interface and implementation) 원칙**이라고 한다.  
소프트웨어는 항상 변경되기 때문에 외부에 공개되는 인터페이스와 내부에 감춰지는 구현을 분할해 설계하는 것이 중요하다. 객체의 모든 것이 외부에 공개돼 있다면 아무리 작은 부분을 수정하더라도 변경에 의한 파급효과가 객체 공동체의 구석구석까지 파고들 것이다.  
자율적인 객체는 외부와 상관없이 메시지를 처리하는 메서드를 스스로 선택할 수 있어야 한다. 따라서 적절한 구현을 선택하고 이를 인터페이스 뒤로 감추는 것은 객체의 자율성을 향상시킬 수 있는 가장 기본적인 방법이다.  
**객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속한다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안 된다.**  
인터페이스와 구현의 분리 원칙은 변경을 관리하기 위한 것이다. 송신자와 수신자가 구체적인 구현 부분이 아니라 느슨한 인터페이스에 대해서만 결합되도록 만드는 것이다.

[캡슐화]  
객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 캡슐화라고 한다. 객체는 상태와 행위를 캡슐화함으로써 충분히 협력적이고 자율적인 존재가 될 수 있다. 캡슐화는 다른 이름으로 **정보 은닉(information hiding)**이라고 부른다.  
캡슐화는 두 가지 관점에서 사용된다.

1. 상태와 행위의 캡슐화  
   객체는 상태와 행위의 조합이다. 깨체는 스스로 자신의 상태를 관리하며 상태를 변경하고 외부에 응답할 수 있는 행동을 내부에 함께 보관한다. 객체는 상태와 행동을 하나의 단위로 묶는 자율적인 실체로 이 관점에서의 캡슐화를 **데이터 캡슐화(data encapsulation)**라고 한다.  
   데이터 캡슐화는 인터페이스와 구현을 분리하기 위한 전제 조건이다. 또한 객체가 자율적이기 위해서는 자기 자신의 상태를 스스로 관리할 수 있어야 하기 때문에 데이터 캡슐화는 자율적인 객체를 만들기 위한 전제 조건이기도 하다.
2. 사적인 비밀의 캡슐화  
   객체는 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 막기 위해 의사소통 가능한 특별 경로만 외부에 노출한다. 이처럼 외부에서 객체와 의사소통할 수 있는 고정된 경로를 공용 인터페이스라고 한다.  
   객체의 공용 인터페이스는 외부에서 전송 가능한 메시지의 집합이다. 외부 객체는 오직 공용 인터페이스에 정의된 메시지를 통해서만 객체에 접근할 수 있다. 객체는 공용 인터페이스를 통해 최대한의 자율성을 보장받을 수 있다.  
   자율적인 객체는 공용 인터페이스를 수정하지 않는 한 자신과 협력하는 외부 객체에 영향을 미치지 않고 내부의 구현을 자유롭게 수정할 수 있다.

객체의 책임을 결정하는 것은 메시지기 때문에 자율적인 책임의 특성은 자율적인 책임을 수행하게 하는 메시지의 특성과도 연결된다.

---

### 7/21(목)

객체지향의 사실과 오해 - 5. 책임과 메시지  
책임의 자율성이 협력의 품질을 결정한다

객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 된다. 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다. 그 이유는 아래와 같다.

1. **자율적인 책임은 협력을 단순하게 만든다.**  
   자율적인 책임은 의도를 명확하게 표현함으로써 협력을 단순하고 이해하기 쉽게 만든다. 자율적인 책임은 세부적인 사항들은 무시하고 의도를 드러내는 하나의 문장으로 표현함으로써 협력은 단순하게 만든다. 이를 적절하게 추상화되었다고 표현한다.
2. **자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.**  
   협력의 양상은 두 가지 관점으로 분리된다. 하나는 외부 객체가 바라보는 외부 관점이고, 다른 하나는 객체가 책임을 수행하는 내부 관점이다. 요청하는 객체가 몰라도 되는 사적인 부분이 객체 내부로 캡슐화되기 떄문에 인터페이스와 구현이 분리된다.
3. **책임이 자율적인 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.**  
   책임이 자율적일수록 변경에 의해 수정돼야 하는 범위가 좁아지고 명확해진다. 변경의 파급효과가 객체 내부로 캡슐화되기 때문에 두 객체 간의 결합도가 낮아진다.
4. **자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.**  
   책임이 자율적일수록 협력이 좀 더 유연해지고 다양한 문맥에서 재활용될 수 있다. 즉 설계가 유연해지고 재사용성이 높아진다.
5. **객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.**  
   객체가 수행하는 책임들이 자율적이면 자율적일수록 객체의 존재 이유를 명확하게 표현할 수 있다. 객체는 동일한 목적을 달성하는 강하게 연관된 책임으로 구성되기 때문이다. 즉 책임이 자율적일수록 객체의 응집도를 높은 상태로 유지하기 쉬워진다.

책임이 자율적일수록 협력이 이해하기 쉬워지고, 객체의 외부와 내부의 구분이 명확해지며, 변경에 의한 파급효과를 제한할 수 있으고, 유연하게 변경할 수 있는 동시에 다양한 문맥에서 재활용할 수 있다. 책임이 자율적일수록 **적절하게 '추상화'되며, '응집도'가 높아지고, '결합도'가 낮아지며, '캡슐화'가 증진되고, '인터페이스와 구현이 명확히 분리'되며, 설계의 '유연성'과 '재사용성'이 향상**된다.

---

### 7/22(금)

객체지향의 사실과 오해 - 6. 객체 지도  
기능 설계 대 구조 설계

여행 중 길을 찾는 상황에서 두 가지 방법을 통해 길을 찾을 수 있다. 첫 번째 방법은 다른 사람에게 길을 물어보는 것으로 '기능적이고 해결책 지향적인 접근법(functional, solution-directed approach)'이다. 이 방법은 일반적이지도, 재사용 가능하지도 않다. 두 번째 방법은 지도에 표시된 길을 따라 가는 방법이다. 지도는 실세계의 지형을 기반으로 만들어진 추상화된 모델이다. 지도를 이용하는 방법은 '구조적이고 문제 지향적인 접근법(structural, problem-directed approach)'이다. 지도는 길을 찾는 데 필요한 구체적인 기능이 아니라 길을 찾을 수 있는 '구조'를 제공한다.  
지도는 다양한 목적을 위해 재사용될 수 있으며 범용적이다. 지도가 범용적인 이유는 지도를 사용하려는 사람들이 원하는 '기능'에 비해 지도에 표시된 '구조'가 더 안정적이기 때문이다.

모든 소프트웨어 제품의 설계에는 두 가지 측면이 존재한다. 하나는 **기능(function)** 측면의 설계이고, 다른 하나는 **구조(structure)** 측면의 설계다. 기능 측면의 설계는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다. 구조 측면의 설계는 제품의 형태가 어떠해야 하는지에 초점을 맞춘다.  
휼륭한 기능이 휼륭한 소프트웨어를 만드는 충분조건이라고 한다면 휼륭한 구조는 휼륭한 소프트웨어를 만들기 위한 필요조건이다. 성공적인 소프트웨어는 휼륭한 기능을 제공하는 동시에 사용자가 원하는 새로운 기능을 빠르고 안정적으로 추가할 수 있다는 특징을 가지고 있다.  
개발자의 삶이 고단하면서 흥미로운 이유는 요구사항이 예측 불가능하게 변경되기 때문이다. 변경되는 요구사항에 대비하기 위해서는 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다. 좋은 설계는 나중에라도 변경할 수 있는 여지를 남겨 놓는 설계다.  
변경에 대비하고 변경의 여지를 남겨 놓는 가장 좋은 방법은 자주 변경되는 기능이 아닌 안정적인 구조를 중심으로 설계하는 것이다. 전통적인 기능 분해(functional decomposition)는 자주 변경되는 기능을 중심으로 설계한 후 구조가 기능에 따르게 한다. 이 방법의 경우 시스템 기능은 더 작은 기능으로 분해되고 각 기능은 서로 밀접하게 관련된 하나의 덩어리를 이루기 때문에 기능이 변경될 경우 기능의 축을 따라 설계된 소프트웨어가 전체적으로 요동친다.  
반면 객체지향 접근방법은 자주 변경되지 않는 안정적인 객체 구조를 바탕으로 시스템 기능을 객체 간의 책임으로 분배한다. 객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만든다. 시스템 기능은 더 작은 책임으로 분할되고 적절한 객체에게 분배되기 때문에 기능이 변경되더라도 객체 간의 구조는 그대로 유지된다. 이것이 객체를 기반으로 책임과 역할을 식별하고 메시지를 기반으로 객체들의 협력 관계를 구축하는 이유다.

---

### 7/23(토)

객체지향의 사실과 오해 - 6. 객체 지도  
두 가지 재료: 기능과 구조, 안정적인 재료: 구조

객체지향 세계를 구축하기 위해서는 사용자에게 제공할 '기능'과 기능을 담을 안정적인 '구조'라는 재료가 준비돼 있어야 한다.

-   구조는 사용자는 이해관계자들이 도메인(domain)에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
-   기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.

기능을 수집하고 표현하기 위한 기법을 **유스케이스 모델링**이라고 하고 구조를 수집하고 표현하기 위한 기법을 **도메인 모델링**이라고 한다. 각각의 모델링 활동의 결과물을 유스케이스와 도메인 모델이라고 한다.

[도메인 모델]  
사용자가 프로그램을 사용하는 대상 분야를 **도메인**이라고 한다. 도메인 모델에서 모델이란 대상을 단순화해서 표현한 것이다. 모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다. 즉 대상을 추상화하고 단순화한 것이다.  
**도메인 모델**이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다. 도메인 모델을 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화한 것이다.  
도메인 모델은 이해관계자들이 바라보는 멘탈 모델(Mental Model)이다. 멘탈 모델이란 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다.  
도널드 노먼은 멘탈 모델을 사용자 모델, 디자인 모델, 시스템 이미지의 세 가지로 구분한다. 사용자 모델은 사용자가 제품에 대해 가지고 있는 개념들의 모습이다. 디자인 모델은 설계자가 마음 속에 갖고 있는 시스템에 대한 개념화다. 시스템 이미지는 최종 제품이다.  
도메인 모델은 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지를 포괄하도록 추상화한 소프트웨어 모델이다. 따라서 도메인 모델은 소프트웨어에 대한 멘탈 모델이다.

[도메인의 모습을 담을 수 있는 객체지향]  
도널드 노먼은 최종 제품은 사용자의 관점을 반영해야 한다고 주장한다. 소프트웨어 개발에서는 최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야 한다고 할 수 있다. 이는 애플리케이션이 도메인 모델을 기반으로 설계돼야 한다는 것을 의미한다.  
객체지향을 사용하면 사용자들이 이해하고 있는 도메인의 구조와 최대한 유사하게 코드를 구조화할 수 있다. 동적인 객체가 가진 복잡성을 극복하기 위해 정적인 타입을 이용해 세상을 단순화할 수 있으며 클래스라는 도구를 이용해 타입을 코드 안으로 옮길 수 있다.  
객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두를 유사한 모습으로 유지하도록 만드는 것이 가능하다. 이러한 객체지향의 특징을 **연결완전성**, 또는 **표현적 차이**라고 한다.

---

### 7/24(일)

객체지향의 사실과 오해 - 6. 객체 지도  
안정적인 재료: 구조

[표현적 차이]  
소프트웨어 객체는 현실 객체를 모방한 것이 아니라 **은유**를 기반으로 재창조한 것이다. 따라서 소프트웨어 객체는 현실 객체가 갖지 못한 특성을 가질 수도 있고 현실 객체가 하지 못하는 행동을 할 수도 있다. 이처럼 소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 **표현적 차이** 또는 **의미적 차이**라고 한다. 핵심은 은유를 통해 현실 객체와 소프트웨어 객체 사이의 차이를 최대한 줄이는 것이다.  
소프트웨어 객체를 창조하기 위해 은유해야 하는 대상은 도메인 모델이다. 도메인 모델을 기반으로 설계하고 구현하는 것은 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있게 한다. 이를 통해 표현적 차이가 줄어들 것이고, 사용자의 멘탈 모델이 그대로 코드에 녹아들 것이다.  
표현적 차이가 중요한 이유는 소프트웨어를 이해하고 수정하기 쉽게 만들어주기 때문이다. 코드의 구조가 도메인의 구조를 반영하기 때문에 도메인을 이해하면 코드를 이해하기 훨씬 수월해진다.

[불안정한 기능을 담는 안정적인 도메인 모델]  
도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것이다. 사용자들은 누구보다 도메인의 '본질적인' 측면을 가장 잘 이해하고 있다.  
본질적이라는 것은 변경이 적고 비교적 그 특성이 오랜 시간 유지된다는 것을 의미한다. 그렇기 때문에 도메인 모델이 기능을 담을 수 있는 안정적인 구조를 제공할 수 있다고 할 수 있다. 도메인 모델은 기능을 구현할 때 참조할 수 있는 궁극적인 지도이다.

---

### 7/25(월)

객체지향의 사실과 오해 - 6. 객체 지도  
불안정한 재료: 기능

[유스케이스]  
기능적 요구사항이란 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것이다. 사용자들은 시스템을 통해 달성하고자 하는 목표가 있다. 휼륭한 기능적 요구사항을 얻기 위해서는 목표를 가진 사용자와 사용자의 목표를 만족시키기 위해 일련의 절차를 수행하는 시스템 간의 '상호작용'관점에서 시스템을 바라봐야 한다.  
사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 **유스케이스**라고 한다.

> 유스케이스란?  
> 시스템의 이해관계자들의 간의 계약을 행위 중심으로 파악한다. 유스케이스는 이해관계자들 중에서 일차 액터라 불리는 행위자의 요청에 대한 시스템의 응답으로서, 다양한 조건하에 있는 시스템의 행위를 서술한다. 일차 액터는 어떤 목표를 달성하기 위해 시스템과의 상호작용을 시작한다. 시스템은 모든 이해관계자들의 요구에 응답하고 이해관계를 보호해야 한다. 특별한 요청과 관계되는 조건에 따라 서로 다른 일련의 행위 혹은 시나리오가 전개될 수 있다. 유스케이스는 이렇게 서로 다른 시나리오를 묶어준다.[앨리스터 코오번 2000]

코오번의 글에서 '일차 액터(primary actor)'란 시스템의 서비스 중 하나를 요청하는 이해관계자로, 하나의 목표를 가지고 유스케이스를 시작하는 액터를 의미한다. 외부 시스템 역시 일차 액터의 범주에 포함시킨다.  
유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다는 점이다. 선발적으로 훝어진 기능에 사용자 목표라는 문맥을 제공함으로써 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 한다.

[유스케이스의 특성]

1. 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다.  
   유스케이스의 핵심은 사용자와 시스템 간의 상호작용을 일련의 이야기 흐름으로 표현하는 것으로, 다이어그램이 아니다.
2. 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.  
   시나리오(scenario)는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다. 유스케이스는 하나의 시나리오가 아니라 사용자의 목표와 관련된 모든 시나리오의 집합이다. 시나리오는 **유스케이스 인스턴스(use case instance)**라고도 한다.
3. 유스케이스는 단순한 피처(feature) 목록과 다르다.  
   피처는 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 것이다. 피처는 연관있는 기능이더라도 서로 연관이 없는 독립적으로 보이게끔 만든다는 단점이 있다. 그러나 유스케이스는 사용자와의 상호작용 흐름 속에서 시스템의 기능에 대해 의사소통할 수 있는 문맥을 얻을 수 있다.
4. 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.  
   유스케이스는 자주 변경되는 사용자 인터페이스 요소는 배제하고 사용자 관점에서 시스템의 행위에 초점을 맞춘다. 이처럼 사용자 인터페이스를 배제한 유스케이스 형식을 **본질적인 유스케이스(essential use case)**라고 한다.
5. 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.  
   유스케이스의 목적은 연관된 시스템의 기능을 이야기 형식으로 모으는 것이지 내부 설계를 설명하는 것이 아니다. 유스케이스에서 객체 설계로의 전환은 공학적인 규칙과 원칙을 기반으로 한 변환 작업이 아니라 경험과 상식, 의사소통을 기반으로 한 창조 작업이다.

[유스케이스는 설계 기법도, 객체지향 기법도 아니다]  
유스케이스는 사용자가 시스템을 통해 무엇을 얻을 수 있고, 어떻게 상호작용할 수 있느냐에 관한 정보만 기술한다. 유스케이스로부터 시스템의 내부 구조를 유추할 수 없다. 또한 유스케이스는 객체지향과도 상관 없다. 유스케이스는 객체지향 이외의 패러다임에서도 적용 가능하며, 객체지향은 다른 방법으로 요구사항을 명시할 수 있다. 유스케이스는 단지 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리 기법일 뿐이다.  
유스케이스 텍스트 안에 도메인 모델에서 사용할 용어에 대한 힌트를 얻을 수 있다. 그러나 유스케이스 안에 도메인 모델을 구축할 수 있는 모든 정보가 포함돼 있다고 착각하면 안된다.

---

### 7/26(화)

객체지향의 사실과 오해 - 6. 객체 지도  
재료 합치기: 기능과 구조의 통합

[도메인 모델, 유스케이스, 그리고 책임-주도 설계]  
도메인 모델은 안정적인 구조를 개념화하기 위해, 유스케이스는 불안정한 기능을 서술하기 위해 가장 일반적으로 사용되는 도구다. 변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배해야 한다.  
객체지향 패러다임은 모든 것이 객체라는 사상에서 출발한다. 따라서 유스케이스에 명시된 기능을 구현하는 프로그래머는 시스템을 사용자로부터 전송된 메시지를 수행하기 위해 책임을 수행하는 거대한 자율적인 객체로 본다. 사용자의 관점에서 시스템 객체는 자신이 전송한 메시지에 응답하는 데 필요한 책임을 수행하는 일종의 객체다.  
책임-주도 설계는 시스템의 기능을 시스템의 책임으로 바꿀 때 처음 적용된다.  
시스템에 할당된 커다란 책임은 시스템 안의 작은 규모의 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화된다. 이때 어떤 객체를 선택할 것인가를 도메인 모델을 통해 결정한다. 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택해야 한다. 이를 통해 소프트웨어와 코드 사이의 표현적 차이를 줄일 수 있다. 협력을 완성하는 데 필요한 메시지를 식별하면서 객체들에게 책임을 할당하고, 협력에 참여하는 객체를 구현하기 위해 클래스를 추가하고 속성과 함꼐 메서드를 구현하면 시스템의 기능을 완성할 수 있다.

> 객체 설계란?  
> 요구사항들을 식별하고 도메인 모델을 생성한 후, 소프트웨어 클래스에 메서드를 추가하고, 요구사항을 충족시키기 위해 객체들 간의 메시지 전송을 정의하라. [Larman]

유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있도록 해준다.  
책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 두 가지 기본 재료인 유스케이스와 도메인 모델을 통합한다.  
도메인 모델에에 명시된 실세계의 객체들은 실세계에서는 수동적인 존재라고 하더라도 소프트웨어 객체로 구현될 때는 스스로 판단하고 행동하는 자율적인 존재로 바뀔 수 있다.  
객체의 이름은 도메인 모델에 포함된 개념으로부터 차용하고, 책임은 도메인 모델에 정의한 개념의 정의에 부합하도록 할당한다. 책임 할당의 기본 원칙은 책임을 수행하는 데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것이다. 이것은 관련된 상태와 행동을 함께 캡슐화하는 자율적인 객체를 낳는다.  
유스케이스에서 출발해 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 **재귀적 합성**이라는 객체지향의 기본 개념을 잘 보여준다. 객체에 대한 재귀는 객체지향의 개념을 모든 추상화 수준에서 적용 가능하게 하는 동시에 객체지향 패러다임을 어떤 곳에서든 일관성 있게 적용할 수 있게 한다.

[기능 변경을 흡수하는 안정적인 구조]  
도메인 모델을 기반으로 객체 구조를 설계하는 이유는 도메인 모델이 안정적이기 때문이다. 도메인 모델은 아래 두 가지 특징을 가진다.

1. 도메인 모델을 구성하는 개념은 비즈니스가 없어지거나 완전히 개편되지 않는 한 안정적으로 유지된다.
2. 도메인 모델을 구성하는 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지된다.

이러한 특징은 도메인 모델을 중심으로 객체 구조를 설계하고 유스케이스의 기능을 객체의 책임으로 분배하는 기본적인 객체지향 설계 방식의 유연함을 잘 보여준다. 안정적인 도메인 모델을 기반으로 시스템의 기능을 구현할 경우 시스템의 기능이 변경되더라도 비즈니스의 핵심 정책이나 규칙이 변경되지 않는 한 전체적인 구조가 한 번에 흔들리지는 않는다.  
객체지향의 가장 큰 장점은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다는 점이다. 이를 통해 도메인 모델링에서 사용한 객체와 개념을 프로그래밍 설계에서의 객체와 클래스로 매끄럽게 변환할 수 있다. 이 같은 특성을 **연결완전성**이라고 한다.  
객체지향은 연결완전성의 역방향 역시 성립한다. 즉, 코드의 변경으로부터 도메인 모델의 변경 사항을 유추할 수 있다. 객체지향에서는 도메인 모델과 코드 모두 동일한 모델링 패러다임을 공유하기 때문에 코드의 수정이 곧 모델의 수정이 된다. 이처럼 모델에서 코드로의 매끄러운 흐름을 의미하는 연결완정성과 반대로 코드에서 모델로의 매끄러운 흐름을 의미하는 것을 **가역성(reversibility)**이라고 한다.  
도메인 모델은 문서나 다이어그램이 아니다. 도메인 모델은 사람들의 머릿속에 들어있는 공유된 멘탈 모델이다. 따라서 별도의 문서나 다이어그램이 없더라도 사람들의 머릿속에 모델이 공유될 수 있다면 충분하다.

---

### 7/27(수)

객체지향의 사실과 오해 - 7. 함께 모으기  
함께 모으기

마틴 파울러는 『UML Distilled 2판』에서 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 대해 설명한다.

1. **개념 관점(Conceptual Perspective)**  
   개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다. 이 관점은 사용자가 도메인을 바라보는 관점을 반영한다. 따라서 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.
2. **명세 관점(Specification Perspective)**  
   명세 관점에 이르면 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다. 명세 관점은 도메인이 아니라 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 즉 객체의 인터페이스를 바라보게 된다. 명세 관점은 프로그래머가 객체의 협력을 위해 '무엇'을 할 수 있는 가에 초점을 맞춘다. "구현이 아니라 인터페이스에 대해 프로그래밍하라"는 격언의 시작은 명세 관점과 구현 관점을 명확하게 구분하는 것이다.
3. **구현 관점(Implementation Perspective)**  
   구현 관점은 프로그래머에게 가장 익숙한 관점으로, 실제 작업을 수행하는 코드와 연관돼 있다. 구현 관점의 초점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다. 따라서 프로그래머는 객체의 책임을 '어떻게' 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

클래스는 위 세 가지 관점을 통해 설계와 관련된 다양한 측면을 드러낼 수 있다. 클래스가 은유하는 개념은 도메인 관점을 반영한다. 클래스의 공통 인터페이스는 명세 관점을 반영한다. 클래스의 속성과 메서드는 구현 관점을 반영한다.  
클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

---

### 7/28(목)

객체지향의 사실과 오해 - 7. 함께 모으기  
커피 전문점 도메인

[커피 주문]  
커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현하는 예제이다.

[커피 전문점이라는 세상]  
커피 전문점 안에는 메뉴판이 존재하고, 그 안에는 아메리카노, 카푸치노, 카라멜 마키아또, 에스프레소의 네 가지 커피 메뉴가 적혀 있다. 이때 메뉴판은 네 개의 메뉴 항목 객체를 포함하는 객체라고 볼 수 있다.  
손님은 메뉴판을 보고 커피를 주문한다. 손님 역시 객체로, 손님 객체는 메뉴판 객체 안에 적힌 메뉴 항목 객체들 중 원라는 메뉴 항목 객체를 하나 선택해 바리스타 객체에게 전달한다.  
바리스타는 주문을 받은 커피를 제조한다. 바리스타는 자율적으로 커피를 제조하는 객체로 제조할 수 있는 커피의 종류는 에메리카노, 카푸치노, 카레멜 마키아또, 에스프레소이다.  
이를 종합하면 객체지향의 관점에서 커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성되어 있다.

위에서 생성한 객체들 간의 관계를 파악를 정리하기 위해 동적인 객체를 정적인 타입으로 추상화할 필요가 있다. 상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입의 인스턴스로 분류할 수 있다.  
손님 객체는 '손님 타입'의 인스턴스로 볼 수 있다. 바리스타 객체는 '바리스타 타입'의 인스턴스로 볼 수 있다. 아메리카노, 에스프레소, 카레멜 마키아또, 카푸치노는 모두 '커피 타입'의 인스턴스로 볼 수 있다. 메뉴판 객체는 '메뉴판 타입'의 인스턴스로 네 개의 항목 객체를 포함할 수 있다. 네 개의 메뉴 항목 객체는 '메뉴 항목 타입'의 인스턴스로 모델링할 수 있다.  
메뉴판 객체는 다수의 메뉴 항목 객체로 구성돼 있다.  
이런 상황에 메뉴 항목 객체가 메뉴판 객체에 포함되어 있다고 할 수 있다. 이 관계는 속이 찬 마름모를 통해 나타낼 수 있다. 메뉴판 타입에서 메뉴 항목 타입쪽으로 향하는 선에 그려진 속이 찬 마음모는 **포함(containment) 관계** 또는 **합성(composition) 관계**를 나타낸다. 메뉴 항목 좌측 아래 숫자를 쓸 수 있는 데 이는 메뉴판에 포함되는 메뉴 항목이 4개라는 것을 의미한다.  
손님 객체는 메뉴판 타입을 알고 있어야 원하는 커피를 선택할 수 있다. 메뉴판 타입은 손님의 일부가 아니므로 이 관계는 합성 관계가 아닌 **연관(association) 관계**이다. 연관 관계는 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 하는 경우로, 타입들 사이를 단순한 선으로 연결하여 표현한다.  
바리스타 타입은 커피를 제조하기 위해 커피 타입을 알고 있어야 하지만 메뉴판 타입과 커피 타입 중 어떤 것도 바리스타의 일부가 아니므로 이 관계 역시 포함관계는 아니다.

위 과정을 통해 커피 전문점 도메인을 구성하는 타입들의 종류와 관계에 대해 정리했다. 이처럼 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 **도메인 모델**이라고 한다.

> 실제로 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이고 어떤 관게가 연관 관계인지는 중요하지 않다. 초점은 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.

---

### 7/29(금)

객체지향의 사실과 오해 - 7. 함께 모으기  
설계하고 구현하기

[커피를 주문하기 위한 협력 찾기]  
객체지향 설계의 첫 번쨰 목표는 휼륭한 객체를 설계하는 것이 아니라 휼륭한 협력을 설계하는 것이다. 휼륭한 객체는 휼륭한 협력을 설계할 때만 얻을 수 있다. 협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다. 이 말은 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다는 것을 의미한다. 메시지를 수신할 객체는 메시지를 처리할 책임을 맡게 되고 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.

커피를 주문하는 협력을 설계할 때 첫 번째 메시지는 '커피를 주문하라'일 것이다. 화살표 위에 '커피를 주문하라'라는 메시지가 있고, 그 메시지 위에 붙은 화살표에는 메시지에 담아 전달될 부가적인 정보인 인자가 있다. 커피를 주문하는 경우에는 메뉴 이름이 인자로 전달된다. 이를 메시지를 표현하면 '커피를 주문하라(아메리카노)'와 같이 인자를 포함하는 형식으로 구현될 것이다.

메시지를 찾았으면 이제 메시지를 처리하기에 적합한 객체를 선택해야 한다. 이때 도메인 모델 안에 책임을 수행하기에 적절한 타입이 존재하는지 살펴보면 된다. 적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들면 된다. 현실 속의 객체와 소프트웨어 객체가 완전히 동일할 수는 없지만 유사한 이름을 붙여 놓으면 유사성을 통해 소프트웨어 객체가 수행해야 하는 책임과 상태를 좀 더 쉽게 유추할 수 있다.

'커피를 주문하라'라는 메시지를 수신할 객체는 손님 객체가 될 것이다. 따라서 메시지를 처리할 객체는 손님 타입의 인스턴스다. 손님 객체는 커피를 주문할 책임을 할당받은 것이다. 손님이 커피를 주문하는 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면 다른 객체에게 이를 요청해야 한다. 이 요청이 바로 손님 객체에서 외부로 전송되는 메시지를 정의한다.  
손님은 메뉴 항목에 대해 알지 못한다. 메뉴 항목은 고객의 일부가 아니라 메뉴판의 일부이기 때문에 고객은 자신이 선택한 메뉴 항목을 누군가가 제공해줄 것을 요청한다. 이때 '메뉴 항목을 찾아라'라는 새로운 메시지가 필요하다.  
이 경우 메시지에 '메뉴 이름'이라는 인자를 포함해 함꼐 전송한다. 화살표 아래에 붙은 손님으로 향하는 작은 화살표는 이 메시지를 수신한 객체가 손님에게 무엇을 응답해야 하는지를 나타낸다. 이 경우 '메뉴 항목을 찾아라'라는 메시지를 수신한 객체는 '메뉴 이름'에 대응되는 '메뉴 항목'을 반환해야 한다. 메뉴판 객체는 메뉴 항목 깨체를 포함하기 떄문에 이 책임을 처리할 수 있는 가장 적절한 후보다.  
손님은 자신이 주문한 커피에 대한 메뉴 항목을 얻었느니 이제 메뉴 항목에 맞는 커피를 제조해달라고 요청할 수 있다. 새로운 요청은 새로운 메시지가 필요하다는 신호다. 손님은 커피를 제조하는 메시지의 인자로 메뉴 항목을 전달하고 반환값으로 제조된 커피를 받아야 한다.
커피를 제조하는 객체는 당연히 바리스타 객체다. 바리스타는 커피를 제조하는 데 필요한 모든 정보를 알고 있다. 아메리카노를 만들기 위한 지식은 바리스타의 상태로, 기술은 바리스타의 행동으로 간주할 수 있다. 이 관점에서 바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재다.  
이제 협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 대략적인 윤곽이 잡혔다. 남은 것은 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 과정이다.

[인터페이스 정리하기]  
위 과정을 통해 얻어낸 것은 객체들의 인터페이스이다. 객체가 수신한 객체의 인터페이스를 결정한다. 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다. 객체를 협력이라는 문맥에서 뗴어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다. 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.

손님 객체의 인터페이스 안에는 '커피를 주문하라'라는 오퍼레이션이 포함돼야 한다. 메뉴판 객체의 인터페이스는 '메뉴 항목을 찾아라'라는 오퍼레이션을 제공하며, 바리스타 객체의 인터페이스는 '커피를 제조하라'라는 오퍼레이션을, 커피 객체는 '생성하라'라는 오퍼레이션을 제공한다.

객체들의 협력은 실행 시간에 컴퓨터 안에서 일어나는 상황을 동적으로 묘사한 모델이다. 실제로 소프트웨어의 구현은 동적인 객체가 아닌 정적인 타입을 이용해 이뤄진다. 따라서 객체들을 포괄하는 타입을 정의한 후 식별된 오퍼레이션을 타입의 인터페이스에 추가해야 한다.  
객체의 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다. 인터페이스에 포함된 오퍼레이션은 외부에서 접근 가능하도록 공용(public)으로 선언돼 있어야 한다.

```Java
class Customer {
   public void order(String menuName) {}

   class MenuItem{

   }

   class Menu {
      public MenuItem choose(String name) {}
   }

   class Barista {
      public Coffee makeCoffee(MenuItem menuItem) {}
   }

   class Coffee {
      public Coffee(MenuItem menuItem) {}
   }
}
```

[구현하기]  
클래스의 인터페이스를 식별했으므로 이제 오퍼레이션을 수행하는 방법을 메서드로 구현하면 된다. Customer는 Menu에게 menuName에 해당하는 MenuItem을 찾아달라고 요청해야 한다. 그리고 받은 MenuItem을 Barista에게 전달해서 원하는 커피를 제조하도록 요청해야 한다. 이때 Customer는 Menu객체와 Barista에 접근하기 위해 Menu 객체와 Barista 객체에 대한 참조를 알고 있어야 한다. 객체가 다른 객체에게 메시지를 전송하기 위해서는 먼저 다른 객체에 대한 참조를 얻어야 한다. 아래 예제 코드에서는 Customer의 order() 메서드의 인자로 Menu와 Barista 객체를 전달하여 참조할 수 있도록 했다. 이 때문에 Customer의 인터페이스를 변경해야 한다. 이처럼 **구현 도중 객체의 인터페이스는 변경될 수 있다.**

```Java
//인터페이스
class Customer {
   public void order(String menuName, Menu menu, Barista barista) {}
}
```

```Java
class Customer {
   public void order(String menuName, Menu menu, Barista barista) {
      MenuItem menuItem = menu.choose(menuName);
      Coffee coffee = barista.makeCoffee(menuItem);
      //...
   }
}
```

Menu는 menuName에 해당하는 MenuItem을 찾아야 하는 책임이 있다. 이 책임을 수행하기 위해서 Menu가 내부적으로 MenuItem을 관리하고 있어야 한다. Menu가 MenuItem의 목록을 포함하게 한다. Menu의 choose() 메서드는 MenuItem의 목록을 하나씩 검사하면서 이름이 동일한 MenuItem을 반환한다. 이때 MenuItem의 목록을 Menu의 속성으로 포함시킨 것 역시 클래스를 구현하는 도중에 결정된 것이다.

```Java
class Menu {
   private List<MenuItem> items;

   public Menu(List<MenuItem> items) {
      this.items = items;
   }

   public MenuItem choose(String name) {
      for(MenuItem each :  items) {
         if(each.getName().equals(name)) {
            return each;
         }
      }
      return null;
   }
}
```

Barista는 MenuItem을 이용해 커피를 제조한다.

```Java
class Barista {
   public Coffee makeCoffee(MenuItem menuItem) {
      Coffee coffee = new Coffee(menuItem);
      return coffee;
   }
}
```

Coffee는 자기 자신을 생성하기 위한 생성자를 제공한다. Coffee는 커피 이름과 가격을 속성으로 가지고 생성자 안에서 MenuItem에 요청을 보내 커피 이름과 가격을 얻은 후 Coffee 속서에 저장한다.

```Java
class Coffee {
   private String name;
   private int price;

   public Coffee(MenuItem menuItem) {
      this.name = menuItem.getName();
      this.price = menuItem.cost();
   }
}
```

MenuItem은 getName()과 cost() 메시지에 응답할 수 있도록 메서드를 구현해야 한다. 이때 MenuItem의 인터페이스를 구성하는 오퍼레이션들은 MenuItem을 구현하는 단계에서 식별했다.

```Java
public class MenuItem {
   private String name;
   private int price;

   public MenuItem(String name, int price) {
      this.name = name;
      this.price = price;
   }

   public int cost() {
      return price;
   }

   public String getName() {
      return name;
   }
}
```

위 커피 전문점 코드를 구현하면서 계속 인터페이스에 대한 수정이 일어났다. 인터페이스는 객체가 다른 객체와 직접적으로 상호작용하는 통로다. 인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다. 그렇기 때문에 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하는 것이 좋다. 설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성하면서 협력의 전체적인 밑그림을 그려보는 것이다. 이것이 **테스트-주도 설계**로 코드를 구현하는 방법이다.
